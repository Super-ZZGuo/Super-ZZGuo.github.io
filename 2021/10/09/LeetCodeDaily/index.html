<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.superzzguo.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="LeetCode每日亿题记录下自己解题的想法和思路。每天进步亿点点，妈妈夸我小天才">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode每日亿题">
<meta property="og:url" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/index.html">
<meta property="og:site_name" content="得闲饮茶の阿伯">
<meta property="og:description" content="LeetCode每日亿题记录下自己解题的想法和思路。每天进步亿点点，妈妈夸我小天才">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/187.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/352.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/15.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/59.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/435_1.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/435_2.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/29.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/38.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/763.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/43.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/230.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/211.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/647.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/1143.png">
<meta property="article:published_time" content="2021-10-09T07:54:14.376Z">
<meta property="article:modified_time" content="2022-04-10T08:22:13.814Z">
<meta property="article:author" content="ZZGuo">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/187.png">

<link rel="canonical" href="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>LeetCode每日亿题 | 得闲饮茶の阿伯</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">得闲饮茶の阿伯</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">三点半饮杯啡，食个包</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">15</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">22</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpeg">
      <meta itemprop="name" content="ZZGuo">
      <meta itemprop="description" content="饮茶先啦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="得闲饮茶の阿伯">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode每日亿题
        </h1>

        <div class="post-meta">


          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-09 15:54:14" itemprop="dateCreated datePublished" datetime="2021-10-09T15:54:14+08:00">2021-10-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-10 16:22:13" itemprop="dateModified" datetime="2022-04-10T16:22:13+08:00">2022-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="LeetCode每日亿题"><a href="#LeetCode每日亿题" class="headerlink" title="LeetCode每日亿题"></a>LeetCode每日亿题</h1><p>记录下自己解题的想法和思路。<br>每天进步亿点点，妈妈夸我小天才</p>
<span id="more"></span>


<h2 id="187-重复的DNA序列"><a href="#187-重复的DNA序列" class="headerlink" title="187. 重复的DNA序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></h2><p>思路：</p>
<p>滑动窗口模拟，每次取长度为十的字符串</p>
<p>两个HashSet集合，<code>setStr</code>维护每次存入的字符串，<code>setAns</code>维护已出现过的字符串</p>
<p>最后用<code>listString</code>来接收<code>setAns</code>的结果集并return即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> L = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; setStr = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        Set&lt;String&gt; setAns = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.length() - L; i++)&#123;</span><br><span class="line">            String str = s.substring(i,i+L);</span><br><span class="line">            <span class="keyword">if</span>(setStr.contains(str))&#123;</span><br><span class="line">                setAns.add(str);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                setStr.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; listString = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String ans : setAns)&#123;</span><br><span class="line">            listString.add(ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> listString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2021/10/09/LeetCodeDaily/187.png"></p>
<blockquote>
<p>官解给的方法一写的更巧妙，可以去看看</p>
</blockquote>
<h2 id="352-将数据流变为多个不相交区间"><a href="#352-将数据流变为多个不相交区间" class="headerlink" title="352. 将数据流变为多个不相交区间"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/data-stream-as-disjoint-intervals/">352. 将数据流变为多个不相交区间</a></h2><p>思路：</p>
<p>用一个boolean的数组维护数据流输入情况</p>
<p>用两个哨兵first和last来判断连续的区间情况并将存入到一个ArrayList中</p>
<p>最后将ArrayList类型转换为一个二维数组return即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SummaryRanges</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">10001</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span>[] arr = <span class="keyword">new</span> <span class="keyword">boolean</span>[NUM];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SummaryRanges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        arr[val] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] getIntervals() &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">int</span> first = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> last = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt;= <span class="number">10000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(first == -<span class="number">1</span>)&#123;</span><br><span class="line">                    first = i;</span><br><span class="line">                    last = i;</span><br><span class="line">                &#125;<span class="keyword">else</span> last = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(first != -<span class="number">1</span>)&#123;</span><br><span class="line">                    res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;first,last&#125;);</span><br><span class="line">                    first = -<span class="number">1</span>;</span><br><span class="line">                    last = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(first != -<span class="number">1</span>)&#123;</span><br><span class="line">             res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;first,last&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>addNum()</code> 为 O(1)<em>O</em>(1)，<code>getIntervals()</code> 为 O(C)，C 固定为10001。</p>
<p>空间复杂度：O(C)，C 固定为10001。</p>
<p>结果如图：</p>
<p><img src="/2021/10/09/LeetCodeDaily/352.png"></p>
<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h2><p>思路：</p>
<p>刚开始直接暴力法，时间复杂度为<strong>O(N3)</strong>,还得考虑去重的步骤，看了题解不如直接使用<strong>排序+双指针</strong>，能将时间复杂度降到O(N2)</p>
<p>先将数组排序，时间复杂度<strong>O(NlogN)</strong></p>
<p>然后固定数组最左端指针<code>i</code>，在<code>i</code>右端使用两个动态指针<code>j、k</code>移动，将三数之和与零进行比较：</p>
<ul>
<li>等于零时，将结果添加进List集合中，然后<code>j</code>指针向右移，<code>k</code>指针向左移</li>
<li>大于零时，<code>k</code>指针向左移且去重</li>
<li>小于零时，<code>j</code>指针向右移动且去重</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; length-<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> j = i+<span class="number">1</span>; <span class="comment">//左指针</span></span><br><span class="line">            <span class="keyword">int</span> k = length-<span class="number">1</span>; <span class="comment">//右指针</span></span><br><span class="line">            <span class="keyword">while</span>(j&lt;k)&#123;</span><br><span class="line">                <span class="keyword">int</span> total = nums[i] + nums[j] + nums[k];</span><br><span class="line">                <span class="keyword">if</span>(total&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//去重且向左移</span></span><br><span class="line">                    <span class="keyword">while</span>(j&lt;k &amp;&amp; nums[k] == nums[--k]);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(total&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//去重且向右移</span></span><br><span class="line">                    <span class="keyword">while</span>(j&lt;k &amp;&amp; nums[j] == nums[++j]);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(nums[i],nums[j],nums[k])));</span><br><span class="line">                    <span class="keyword">while</span>(j&lt;k &amp;&amp; nums[k] == nums[--k]);</span><br><span class="line">                    <span class="keyword">while</span>(j&lt;k &amp;&amp; nums[j] == nums[++j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度： <strong>O(N2)<strong>，固定指针<code>i</code>复杂度</strong>O(N)</strong>,动态双指针<code>i</code>、<code>j</code>**O(N)**的复杂度</p>
<p>空间复杂度：**O(1)**，指针占用常数大小空间</p>
<p>结果如图：</p>
<p><img src="/2021/10/09/LeetCodeDaily/15.png"></p>
<blockquote>
<p>代码中最令人感叹的是指针去重且移动的操作：</p>
<p>如：<code>while(j&lt;k &amp;&amp; nums[k] == nums[--k]);</code></p>
<p>每次看大佬题解都感觉受益匪浅</p>
</blockquote>
<h2 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h2><p>思路：</p>
<ul>
<li>模拟填入过程：<ul>
<li>设立<strong>上下左右</strong>四个边界，上、左边界初始值为0，右、下边界初始值为n-1</li>
<li>始终按照四个方向：从左到右、从上到下、从右到左、从下到上<ul>
<li>填入数字达到边界后，对应的边界向内缩小</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>,num = n * n;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,top = <span class="number">0</span>,right = n-<span class="number">1</span>,down = n-<span class="number">1</span>; <span class="comment">//左上右下四个边界</span></span><br><span class="line">        <span class="keyword">while</span>(count &lt;= num)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =left;i &lt;= right;i++) res[top][i] = count++;<span class="comment">//左边界left到右边界right，top行填完后top++</span></span><br><span class="line">            top++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =top;i &lt;= down;i++) res[i][right] = count++;<span class="comment">//上边界top到下边界down，right列填完后right--</span></span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =right;i &gt;= left;i--) res[down][i] = count++;<span class="comment">//右边界right到左边界left，down行填完后down--</span></span><br><span class="line">            down--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =down;i &gt;= top;i--) res[i][left] = count++;<span class="comment">//下边界down到上边界top，left列填完后left++</span></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="/2021/10/09/LeetCodeDaily/59.png"></p>
<h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a></h2><p>思路：</p>
<ul>
<li>按照数组右区间大小升序排序，参考大佬<strong>代码随想录</strong>的一张图：<img src="/2021/10/09/LeetCodeDaily/435_1.png"><ul>
<li>使用右区间最小数组1依次向右判断，当达到数组4时符合条件<code>count++</code>,此时从数组4继续向右判断</li>
</ul>
</li>
<li>根据条件判断出符合条件的区间数量<code>count</code>，则剩下的就是需要移除的区间数量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(intervals,(a,b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ;i &lt; intervals.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &lt;= intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">                num = intervals[i][<span class="number">1</span>];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.length - count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<strong>O(nlogn)</strong>,有一个快排</p>
<p>空间复杂度：<strong>O(1)</strong></p>
<p>结果如图：<br><img src="/2021/10/09/LeetCodeDaily/435_2.png"></p>
<h2 id="29-两数相除"><a href="#29-两数相除" class="headerlink" title="29. 两数相除"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/divide-two-integers/">29. 两数相除</a></h2><p>思路：</p>
<ul>
<li>减法，被除数循环减去除数，但是效率比较低<ul>
<li>位运算，计算机进行位运算时的效率比较高，通过右位移找出满足**<code>2^i</code><em>除数&lt;=被除数*<em>最大的<code>i</code>,此时被除数减去</em></em><code>2^i</code>*除数**，再找剩下满足条件的<code>i</code>,以此类推</li>
<li>举个例子，100/6—&gt; <em><em><code>2^4</code><em>6&lt;=100</em></em>,此时最大的<code>i</code>是4,剩下的100-96 = 4无法满足</em><em><code>2^i</code><em>除数&lt;=被除数</em></em>,则商为16</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">boolean</span> negative = (dividend ^ divisor) &lt; <span class="number">0</span>;<span class="comment">//符号判断</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> num1 = Math.abs((<span class="keyword">long</span>)dividend);</span><br><span class="line">        <span class="keyword">long</span> num2 = Math.abs((<span class="keyword">long</span>)divisor);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span> ; i &gt;= <span class="number">0</span> ; i--)&#123; </span><br><span class="line">            <span class="keyword">if</span>((num1 &gt;&gt; i) &gt;= num2)&#123; <span class="comment">//找出最大的数divisor*2^n</span></span><br><span class="line">                res += <span class="number">1</span>&lt;&lt;i;         <span class="comment">//结果加上2^n</span></span><br><span class="line">                num1 -= num2&lt;&lt;i;     <span class="comment">//计算剩余被除数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> negative ? -res:res;  <span class="comment">//符号互异取反</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2021/10/09/LeetCodeDaily/29.png"></p>
<h2 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38. 外观数列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-and-say/">38. 外观数列</a></h2><p>思路：</p>
<ul>
<li><p>使用双指针，截取<strong>相同字符</strong>的每个组，按照题意模拟即可</p>
<ul>
<li>依次遍历每个组</li>
<li>依次填入<code>n</code>(指针下标<strong>相减</strong>)个<code>m</code>（填入<strong>first</strong>指针的数）</li>
<li>进行下一次遍历</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n ; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> first = <span class="number">0</span> ,last = <span class="number">0</span>;</span><br><span class="line">            StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">while</span>(last &lt; str.length())&#123;</span><br><span class="line">                <span class="keyword">while</span>(last &lt; str.length() &amp;&amp; str.charAt(first) == str.charAt(last)) last++;</span><br><span class="line">                sb.append(Integer.toString(last - first)).append(str.charAt(first));</span><br><span class="line">                first = last;</span><br><span class="line">            &#125;</span><br><span class="line">            str = sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2021/10/09/LeetCodeDaily/38.png"></p>
<p>时间复杂度：O(N*M),N-&gt;给定正整数n，M-&gt;生成字符串长度</p>
<p>空间复杂度：O(M)，M-&gt;生成字符串长度</p>
<h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-labels/">763. 划分字母区间</a></h2><p>思路：</p>
<ul>
<li>最难的是如何划分好符合条件的片段<ul>
<li>先用一个<strong>数组</strong>记录每个字母的最远下标(也可以用<strong>HashMap</strong>来记录)</li>
<li>用两个下标截取片段<ul>
<li>当前遍历字母的最远下标一定是在当前片段中，即<code>end</code>大于等于当前字母的最远下标</li>
<li>当遍历<code>i</code>访问到下标<code>end</code>时，这个片段即是符合条件的片段(贪心)</li>
</ul>
</li>
<li>将当前片段结果加入结果集，进行后续片段的遍历</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">            arr[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i; <span class="comment">//记录字母最远下标</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">            end = Math.max(end,arr[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]); <span class="comment">//当前遍历字母的最远下标一定是在当前片段中</span></span><br><span class="line">            <span class="keyword">if</span>(i == end)&#123;</span><br><span class="line">                res.add(end - start + <span class="number">1</span>);</span><br><span class="line">                start = end + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2021/10/09/LeetCodeDaily/763.png"></p>
<p>时间复杂度：log(N),遍历两次数组</p>
<p>空间复杂度：log(m),m是字符串中的字符集，这题中m为26(只包含26个小写字母)</p>
<blockquote>
<p>Tips：</p>
<p>对于贪心的思想掌握的还是不够好，以局部最优求出全局最优。</p>
</blockquote>
<h2 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/multiply-strings/">43. 字符串相乘</a></h2><p>思路：</p>
<p>将乘数每一位和被乘数<strong>相乘累加</strong>的结果放入对应数组中，乘数和被乘数长度分别为<code>en1</code>和<code>len2</code>，故数组的大小不超过<strong>len1+len2</strong>（例如100 * 100 = 1000，3 + 3 &gt;= 4 ）</p>
<ul>
<li>两个for循环得到结果数组后，还得对数组进行操作才能获得最终数组(模拟乘法)<ul>
<li>数组下标从右到左，将当前数组下标的值与10除<strong>取商</strong>累加到左一位</li>
<li>当前数组下标与10除<strong>取余</strong></li>
</ul>
</li>
<li>获得最终数组后，判断数组arr[0]为0或1进行字符串拼接操作（题目要求不以0开头）</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1.equals(<span class="string">&quot;0&quot;</span>) || num2.equals(<span class="string">&quot;0&quot;</span>)) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len1 = num1.length(),len2 = num2.length();</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[len1 + len2];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> curnum1 = num1.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = len2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> curnum2 = num2.charAt(j) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                arr[i + j + <span class="number">1</span>] += curnum1 * curnum2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = len1 + len2 -<span class="number">1</span> ; k &gt; <span class="number">0</span>; k--)&#123;</span><br><span class="line">            arr[k - <span class="number">1</span>] += arr[k]/<span class="number">10</span>;</span><br><span class="line">            arr[k] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = arr[<span class="number">0</span>] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        StringBuffer res = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span>(index &lt; len1 + len2)&#123;</span><br><span class="line">            res.append(arr[index]);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结果：</p>
<p><img src="/2021/10/09/LeetCodeDaily/43.png"></p>
<p>时间复杂度：<strong>O(m*n)</strong>,其中<code>m</code>和<code>n</code>分别是<code>num1</code>和<code>num2</code>的长度</p>
<p>空间复杂度：**O(m+n)**，</p>
<h2 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h2><p>思路：</p>
<p>因为是二叉搜索树，所以可以用栈按中序遍历来访问二叉树</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stk = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>|| !stk.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.pop();</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">if</span>( k == <span class="number">0</span> )&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2021/10/09/LeetCodeDaily/230.png"></p>
<p>时间复杂度：<code>O(H+k)</code>,H是树的高度,当树是平衡树时，可以取<code>O(logN+k)</code></p>
<p>空间复杂度：<code>O(H)</code>,栈中最多存H个元素</p>
<blockquote>
<p>Tips;</p>
<p>记录这题的目的是自从学习数据结构后很久没做树的题目了，最近开始刷题时遇到的第一道树的题目，故记录下来。</p>
</blockquote>
<h2 id="211-添加与搜索单词-数据结构设计"><a href="#211-添加与搜索单词-数据结构设计" class="headerlink" title="211. 添加与搜索单词 - 数据结构设计"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/">211. 添加与搜索单词 - 数据结构设计</a></h2><p>思路：</p>
<p>简单暴力的方法</p>
<ul>
<li>用<strong>HashMap</strong>存**<code>键：值</code><strong>为</strong><code>字符串长度：相同长度下不同的单词</code>**</li>
<li>查找的时候，从<strong>HashMap</strong>取出相同长度下的<strong>set集合</strong><ul>
<li>先考虑不带 <code>&#39;.&#39;</code>的单词</li>
<li>对于含有 <code>&#39;.&#39;</code>的单词再拆放入数组中逐个比较</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer,Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//根据字符串长度分开存放</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordDictionary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = word.length();</span><br><span class="line">        <span class="keyword">if</span>(map.get(len) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            map.get(len).add(word);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            set.add(word);</span><br><span class="line">            map.put(len,set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = map.get(word.length());</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span>(set == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(word)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">char</span>[] charword = word.toCharArray(); </span><br><span class="line">        P:<span class="keyword">for</span>(String str : set)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.length() != word.length()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">char</span>[]  charstr = str.toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; word.length(); i++)&#123; <span class="comment">//每个字符比较</span></span><br><span class="line">                <span class="keyword">if</span>(charword[i] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; charword[i] != charstr[i]) <span class="keyword">continue</span> P; <span class="comment">//遍历下一个字符</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2021/10/09/LeetCodeDaily/211.png"></p>
<blockquote>
<p>该题的官方解法是使用前缀树进行求解</p>
</blockquote>
<h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串</a></h2><p>思路：</p>
<p>回文字符串，可以按照<strong>回文中心向两侧延伸</strong>的思路来查找有多少个回文字符串</p>
<ul>
<li>回文中心，按照奇偶的区分来说，回文中心不是单个字符就是两个同样的字符如<code>a</code>或<code>aa</code>,当三个字符的情况可以视作为一个回文串</li>
<li>其次，回文中心的数量按照观察来说，有<code>2*len-2</code>个(其中len为字符串长度)</li>
<li>最后可以定义两个指针向两侧延伸<ul>
<li>当回文中心为奇数时，两指针重叠</li>
<li>当回文中心为偶数时，两指针一左一右</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i / <span class="number">2</span>, r = i / <span class="number">2</span> + i % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; len &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">                --l;</span><br><span class="line">                ++r;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2021/10/09/LeetCodeDaily/647.png"></p>
<p>时间复杂度：<strong>O(n^2)</strong>,枚举回文中心<strong>O(n)</strong>,指针延展查找回文子串<strong>O(n)</strong></p>
<p>空间复杂度：<strong>O(1)</strong></p>
<h2 id="229-求众数-II"><a href="#229-求众数-II" class="headerlink" title="229. 求众数 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element-ii/">229. 求众数 II</a></h2><p>先放上代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>,len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(key) &gt; len/<span class="number">3</span>) res.add(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是时间复杂度和空间复杂度均为**O(n)**的解法,其中<code>n</code>为数组的长度</p>
<p>但是题目的进阶要求是把空间复杂度优化到<strong>O(1)</strong>,题解给了一种很神奇的方法——<strong>摩尔投票法</strong>,思路如下：</p>
<ul>
<li><p>题目要求找出超过【n/3】的元素，实际上隐含了一个条件——结果集内只有两个结果</p>
</li>
<li><p>大致cv一下摩尔投票法的思路</p>
<ul>
<li>选票数超过一半的候选人时，投票结果如数组【A,B,C,C,C,A】</li>
<li>第一张票和第二张票不同，分别为A和B，互相抵消</li>
<li>第三四五张票相同，则增加C候选人可以抵消的票数</li>
<li>后面还有一张A抵消C一次，此时候选人是C，则统计一下C在数组中出现的次数，超过一半则候选人是C</li>
</ul>
</li>
<li><p>可以看出摩尔投票法是一个抵消的思路，同时由票数<strong>超过1/2即被选取</strong>扩展一下至票数<strong>超过1/n时被选取</strong>，则最理想情况下会有<strong>n-1个被选取</strong></p>
</li>
</ul>
<p>贴上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建返回值</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// 初始化两个候选人candidate，和他们的计票</span></span><br><span class="line">        <span class="keyword">int</span> cand1 = nums[<span class="number">0</span>], count1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cand2 = nums[<span class="number">0</span>], count2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 摩尔投票法，分为两个阶段：配对阶段和计数阶段</span></span><br><span class="line">        <span class="comment">// 配对阶段</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">// 投票</span></span><br><span class="line">            <span class="keyword">if</span> (cand1 == num) &#123;</span><br><span class="line">                count1++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cand2 == num) &#123;</span><br><span class="line">                count2++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第1个候选人配对</span></span><br><span class="line">            <span class="keyword">if</span> (count1 == <span class="number">0</span>) &#123;</span><br><span class="line">                cand1 = num;</span><br><span class="line">                count1++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第2个候选人配对</span></span><br><span class="line">            <span class="keyword">if</span> (count2 == <span class="number">0</span>) &#123;</span><br><span class="line">                cand2 = num;</span><br><span class="line">                count2++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            count1--;</span><br><span class="line">            count2--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数阶段</span></span><br><span class="line">        <span class="comment">// 找到了两个候选人之后，需要确定票数是否满足大于 N/3</span></span><br><span class="line">        count1 = <span class="number">0</span>;</span><br><span class="line">        count2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cand1 == num) count1++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cand2 == num) count2++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count1 &gt; nums.length / <span class="number">3</span>) res.add(cand1);</span><br><span class="line">        <span class="keyword">if</span> (count2 &gt; nums.length / <span class="number">3</span>) res.add(cand2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度依然是**O(n),<strong>但是空间复杂度已经只有</strong>O(1)**了</p>
<h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h2><blockquote>
<p>很经典的一道题，记录一下</p>
</blockquote>
<p>思路</p>
<p>官解说可以用<strong>Hashmap</strong>来存储中序遍历数组的下标，这样在后续递归中，中序遍历数组，定位根节点位置时时间复杂度只有O(1)，真是妙蛙种子吃着妙脆角妙进了米奇妙妙屋，妙到家了～</p>
<ul>
<li><p>根据<strong>先序遍历</strong>数组的<strong>第一位</strong>判断为根节点</p>
</li>
<li><p>根据根节点判断<strong>中序遍历</strong>的左子树和右子树</p>
<ul>
<li><p>递归传入下标时，注意子树左右边界：</p>
<ul>
<li><p>很显然中序遍历数组中查找到根节点后<strong>其左右分别是左右子树的区间</strong></p>
</li>
<li><p>先序遍历数组中<strong>最左下标对应的为根节点</strong>，根据中序遍历左侧数组下标来求得<strong>左子树数量</strong>，同理求得右<strong>子树数量</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; res = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; inorder.length; i++)&#123;</span><br><span class="line">            res.put(inorder[i],i); </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> makeTree(preorder,inorder,<span class="number">0</span>,preorder.length - <span class="number">1</span>,<span class="number">0</span>,inorder.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">makeTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> pre_left,<span class="keyword">int</span> pre_right,<span class="keyword">int</span> in_left,<span class="keyword">int</span> in_right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pre_left &gt; pre_right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//先序遍历数组的第一位即是根节点</span></span><br><span class="line">        <span class="keyword">int</span> pre_root = pre_left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在中序遍历中定位根节点</span></span><br><span class="line">        <span class="keyword">int</span> in_root = res.get(preorder[pre_root]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode((preorder[pre_root]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中序遍历数组根节点的左侧 -&gt; 得到左子树中节点的数目</span></span><br><span class="line">        <span class="keyword">int</span> size_left_subtree = in_root - in_left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归构造左子树</span></span><br><span class="line">        root.left = makeTree(preorder,inorder,pre_left + <span class="number">1</span>,pre_left + size_left_subtree ,in_left,in_right - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归构造右子树</span></span><br><span class="line">        root.right = makeTree(preorder,inorder,pre_left + size_left_subtree + <span class="number">1</span>,pre_right,in_root + <span class="number">1</span>,in_right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<strong>O(n)</strong>,n为树中节点的个数</p>
<p>空间复杂度：**O(n)**，n为HashMap的空间+返回结果的空间+递归时栈空间(树高度)</p>
<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><blockquote>
<p>最经典的BFS了</p>
<p>之前学数据结构时用c++实现的，现在时隔很久，正式开始算法时用java实现</p>
</blockquote>
<p>思路</p>
<p>迭代方法：</p>
<p>用一个队列来维护当前层的节点，用一个list集合来维护当前层节点的值，每遍历一次队列后，再将list集合添加进最终结果集中</p>
<ul>
<li>用**队列(queue)**来存放当前层的节点</li>
<li>在遍历<strong>队列</strong>(节点)时,临时创建一个**集合(ArrayList)**来存放每一层节点的值</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">		<span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;(); <span class="comment">//存放结果集</span></span><br><span class="line">		LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;(); <span class="comment">//存放结点</span></span><br><span class="line">		<span class="comment">//将根节点放入队列中</span></span><br><span class="line">		queue.add(root);</span><br><span class="line">		<span class="keyword">while</span>(queue.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">//获取当前队列的长度，这个长度相当于 当前这一层的节点个数</span></span><br><span class="line">			<span class="keyword">int</span> size = queue.size();</span><br><span class="line">			ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">			<span class="comment">//将队列中的元素都拿出来(也就是获取这一层的节点)，放到临时list中</span></span><br><span class="line">			<span class="comment">//如果节点的左/右子树不为空，也放入队列中</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;++i) &#123;</span><br><span class="line">				TreeNode t = queue.remove();</span><br><span class="line">				tmp.add(t.val);</span><br><span class="line">				<span class="keyword">if</span>(t.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">					queue.add(t.left);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(t.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">					queue.add(t.right);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//将临时list加入最终返回结果中</span></span><br><span class="line">			res.add(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<strong>O(N)</strong></p>
<p>空间复杂度：<strong>O(h)</strong>,h是树的高度</p>
<h2 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h2><blockquote>
<p>记录这题的目的是因为相比于暴力法O(n^2)的时间复杂度，有一种优化方法——单调栈法，时间复杂度可以优化到O(n+m)，这种方法也是专门解这一类题目的优化解法</p>
</blockquote>
<p>思路</p>
<ul>
<li>用一个<strong>HashMap</strong>来记录<code>nums2</code>数组中每个数其右边第一个比它大的数字<ul>
<li>用一个栈来逆序遍历<code>nums2</code>，记录比<code>nums2[i]</code>大的数,逆序遍历存入栈时，离<code>nums2[i]</code>右边最近的数在栈顶<ul>
<li>这一步是<strong>单调栈法</strong>的精华，妙到我无法用<strong>精炼的文字</strong>来描述，题目要求左边更大的元素时，就可以顺序遍历</li>
</ul>
</li>
</ul>
</li>
<li>在<strong>HashMap</strong>中查看<code>nums1</code>对应的结果</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.length, m = nums2.length;</span><br><span class="line">        Deque&lt;Integer&gt; d = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = nums2[i];</span><br><span class="line">            <span class="keyword">while</span> (!d.isEmpty() &amp;&amp; d.peekLast() &lt;= x) d.pollLast(); <span class="comment">//比nums2[i]小的元素出栈</span></span><br><span class="line">            map.put(x, d.isEmpty() ? -<span class="number">1</span> : d.peekLast());</span><br><span class="line">            d.addLast(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) ans[i] = map.get(nums1[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">作者：AC_OIer</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/next-greater-element-i/solution/gong-shui-san-xie-yi-ti-shuang-jie-bian-n6nwz/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure>

<blockquote>
<p>代码转载自三叶姐，问就是她的暴力法写的太优雅了，自愧不如</p>
</blockquote>
<p>时间复杂度：<strong>O(m+n)</strong>, **O(m)**维护单调栈+O(n)构造答案</p>
<p>空间复杂度：<strong>O(m)</strong></p>
<h2 id="869-重新排序得到-2-的幂"><a href="#869-重新排序得到-2-的幂" class="headerlink" title="869. 重新排序得到 2 的幂"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reordered-power-of-2/">869. 重新排序得到 2 的幂</a></h2><blockquote>
<p>记录这题的目的是，很多时候并没有想出一个很好的解题思路(简单or简洁)，可能是题量还不够，思路还没扩展开来</p>
</blockquote>
<p>思路：</p>
<p>直接暴力回溯的， 在范围内满足<code>2 的幂</code>的数字不多</p>
<p>但是匹配上写的方法很乱，这里放上一种很好的思路</p>
<p><strong>词频统计</strong></p>
<ul>
<li>提前找出符合范围内满足<code>2 的幂</code>的数字，遍历每一个数字时，将该数字转换为num[对应位数字]{该数字出现次数}<ul>
<li>把给定<code>正整数N</code>转换为num[对应位数字]{该数字出现次数}</li>
<li>两个数组进行匹配</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; res = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">reorderedPowerOf2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;= (<span class="keyword">int</span>)<span class="number">1e9</span>+<span class="number">10</span>; i*=<span class="number">2</span>)&#123;</span><br><span class="line">            res.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            cnt[n%<span class="number">10</span>]++;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lo:<span class="keyword">for</span>(<span class="keyword">int</span> num : res)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] resCnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">            <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">                resCnt[num%<span class="number">10</span>]++;</span><br><span class="line">                num /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt[i] != resCnt[i]) <span class="keyword">continue</span> lo;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度： O(C∗logn)</p>
<p>空间复杂度：O(C),C为数组空间大小</p>
<h2 id="1218-最长定差子序列"><a href="#1218-最长定差子序列" class="headerlink" title="1218. 最长定差子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/">1218. 最长定差子序列</a></h2><p>思路</p>
<p>刚开始考虑使用<code>n^2</code>时间复杂度的暴力，一想可能会超时，遂打算用Hashmap来解决，但是自己对dp的学习还是不够深入，在转移方程上卡住了。。。</p>
<p>哈希表+DP</p>
<p>这题的关键是在于找到正确的转移方程：</p>
<ul>
<li><em>dp</em>[<em>v</em>]=<em>dp</em>[<em>v</em>−<em>d</em>]+1</li>
</ul>
<p>代码</p>
<blockquote>
<p>这里放的是官方的题解，问就是写的比我优雅简洁。。。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> difference)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; dp = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : arr) &#123;</span><br><span class="line">            dp.put(v, dp.getOrDefault(v - difference, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            ans = Math.max(ans, dp.get(v));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<em>O</em>(<em>n</em>)，其中 <em>n</em> 是数组 <em>arr</em> 的长度。</p>
<p>空间复杂度：<em>O</em>(<em>n</em>)。哈希表需要 O*(*n) 的空间。</p>
<h2 id="319-灯泡开关-数论"><a href="#319-灯泡开关-数论" class="headerlink" title="319. 灯泡开关 数论"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bulb-switcher/">319. 灯泡开关</a> 数论</h2><blockquote>
<p>很经典的数论题</p>
</blockquote>
<p>思路</p>
<p>首先，从约数下手，不难得出，约数为偶数的的灯泡，最后会熄灭，同理，约数为奇数的灯泡，最后会亮着。</p>
<p>然后，由约数的定义可得，对于数字<strong>k</strong>而言，如果他有约数x，那么一定有相对应的约数字<strong>y</strong>成对出现，使得<strong>k=x*y</strong>，同时，只有约数为<strong>「完全平方数」</strong>时，才会有<strong>奇数个</strong>的约数，否则则为<strong>偶数个</strong></p>
<p>举个🌰：</p>
<p>💡灯泡8⃣️的约数有：1、2、4、8，相对应的是-&gt;亮、灭、亮、灭</p>
<p>💡灯泡9⃣️的约数有：1、3、9，相对应的是-&gt;亮、灭、亮</p>
<p>最后，就是求给定n的约数，考虑到开方，结果向下取整。</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bulbSwitch</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.floor(Math.sqrt(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(1)</p>
<h2 id="1143-最长公共子序列-动态规划"><a href="#1143-最长公共子序列-动态规划" class="headerlink" title="1143. 最长公共子序列 动态规划"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a> 动态规划</h2><p>思路</p>
<p>二维数组+DP</p>
<p>状态定义：<code>dp[i][j]</code>代表考虑text1 前<code>i</code>个字符、考虑text2前<code>j</code>个字符</p>
<p>那么对于「转移方程」来说</p>
<ul>
<li>当字符串<code>cs1[i] == cs[j]</code>：<code>dp[i][j] == dp[i-1][j-1] +1</code></li>
<li>当字符串<code>cs1[i] != cs[j]</code>：<code>dp[i][j]=max(dp[i][j-1],dp[i-1][j])</code></li>
</ul>
<blockquote>
<p>这里放一张官解的图</p>
</blockquote>
<p><img src="/2021/10/09/LeetCodeDaily/1143.png"></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = text1.length(), m = text2.length();</span><br><span class="line">        <span class="keyword">char</span>[] cs1 = text1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] cs2 = text2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ;j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cs1[i-<span class="number">1</span>] == cs2[j-<span class="number">1</span>]) dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.max(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n * m)</p>
<p>空间复杂度：O(n * m)</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>ZZGuo
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/" title="LeetCode每日亿题">http://www.superzzguo.com/2021/10/09/LeetCodeDaily/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LeetCode/" rel="tag"># LeetCode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/02/Go/" rel="prev" title="Golang入门">
      <i class="fa fa-chevron-left"></i> Golang入门
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/10/15/Mysql_LeftmostMatchingPrinciple/" rel="next" title="Mysql最左匹配原则">
      Mysql最左匹配原则 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#LeetCode%E6%AF%8F%E6%97%A5%E4%BA%BF%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">LeetCode每日亿题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#187-%E9%87%8D%E5%A4%8D%E7%9A%84DNA%E5%BA%8F%E5%88%97"><span class="nav-number">1.1.</span> <span class="nav-text">187. 重复的DNA序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#352-%E5%B0%86%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8F%98%E4%B8%BA%E5%A4%9A%E4%B8%AA%E4%B8%8D%E7%9B%B8%E4%BA%A4%E5%8C%BA%E9%97%B4"><span class="nav-number">1.2.</span> <span class="nav-text">352. 将数据流变为多个不相交区间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">1.3.</span> <span class="nav-text">15. 三数之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-II"><span class="nav-number">1.4.</span> <span class="nav-text">59. 螺旋矩阵 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="nav-number">1.5.</span> <span class="nav-text">435. 无重叠区间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4"><span class="nav-number">1.6.</span> <span class="nav-text">29. 两数相除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97"><span class="nav-number">1.7.</span> <span class="nav-text">38. 外观数列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"><span class="nav-number">1.8.</span> <span class="nav-text">763. 划分字母区间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#43-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98"><span class="nav-number">1.9.</span> <span class="nav-text">43. 字符串相乘</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">1.10.</span> <span class="nav-text">230. 二叉搜索树中第K小的元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#211-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.11.</span> <span class="nav-text">211. 添加与搜索单词 - 数据结构设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-number">1.12.</span> <span class="nav-text">647. 回文子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#229-%E6%B1%82%E4%BC%97%E6%95%B0-II"><span class="nav-number">1.13.</span> <span class="nav-text">229. 求众数 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.14.</span> <span class="nav-text">105. 从前序与中序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.15.</span> <span class="nav-text">102. 二叉树的层序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I"><span class="nav-number">1.16.</span> <span class="nav-text">496. 下一个更大元素 I</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#869-%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B0-2-%E7%9A%84%E5%B9%82"><span class="nav-number">1.17.</span> <span class="nav-text">869. 重新排序得到 2 的幂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1218-%E6%9C%80%E9%95%BF%E5%AE%9A%E5%B7%AE%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">1.18.</span> <span class="nav-text">1218. 最长定差子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#319-%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3-%E6%95%B0%E8%AE%BA"><span class="nav-number">1.19.</span> <span class="nav-text">319. 灯泡开关 数论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">1.20.</span> <span class="nav-text">1143. 最长公共子序列 动态规划</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->



      <div class="site-overview-wrap sidebar-panel">

        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZZGuo"
      src="/images/head.jpeg">
  <p class="site-author-name" itemprop="name">ZZGuo</p>
  <div class="site-description" itemprop="description">饮茶先啦</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Super-ZZGuo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Super-ZZGuo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>




      </div>

      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86
        src="//music.163.com/outchain/player?type=2&id=65592&auto=1&height=66">
      </iframe>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZZGuo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":true},"log":false});</script></body>
</html>
