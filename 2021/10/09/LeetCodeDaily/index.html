<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.superzzguo.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="LeetCode每日亿题记录下自己解题的想法和思路。每天进步亿点点，妈妈夸我小天才">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode每日亿题">
<meta property="og:url" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/index.html">
<meta property="og:site_name" content="得闲饮茶の阿伯">
<meta property="og:description" content="LeetCode每日亿题记录下自己解题的想法和思路。每天进步亿点点，妈妈夸我小天才">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/187.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/352.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/15.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/59.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/435_1.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/435_2.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/29.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/38.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/763.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/43.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/230.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/211.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/647.png">
<meta property="og:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/1143.png">
<meta property="article:published_time" content="2021-10-09T07:54:14.376Z">
<meta property="article:modified_time" content="2022-04-10T08:22:13.814Z">
<meta property="article:author" content="ZZGuo">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/187.png">

<link rel="canonical" href="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>LeetCode每日亿题 | 得闲饮茶の阿伯</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">得闲饮茶の阿伯</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">三点半饮杯啡，食个包</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">13</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">9</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">19</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpeg">
      <meta itemprop="name" content="ZZGuo">
      <meta itemprop="description" content="饮茶先啦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="得闲饮茶の阿伯">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode每日亿题
        </h1>

        <div class="post-meta">


          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-09 15:54:14" itemprop="dateCreated datePublished" datetime="2021-10-09T15:54:14+08:00">2021-10-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-10 16:22:13" itemprop="dateModified" datetime="2022-04-10T16:22:13+08:00">2022-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="LeetCode每日亿题"><a href="#LeetCode每日亿题" class="headerlink" title="LeetCode每日亿题"></a>LeetCode每日亿题</h1><p>记录下自己解题的想法和思路。<br>每天进步亿点点，妈妈夸我小天才</p>
<span id="more"></span>


<h2 id="187-重复的DNA序列"><a href="#187-重复的DNA序列" class="headerlink" title="187. 重复的DNA序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></h2><p>思路：</p>
<p>滑动窗口模拟，每次取长度为十的字符串</p>
<p>两个HashSet集合，<code>setStr</code>维护每次存入的字符串，<code>setAns</code>维护已出现过的字符串</p>
<p>最后用<code>listString</code>来接收<code>setAns</code>的结果集并return即可</p>
<pre><code class="java">class Solution &#123;
    static final int L = 10;
    public List&lt;String&gt; findRepeatedDnaSequences(String s) &#123;
        Set&lt;String&gt; setStr = new HashSet&lt;String&gt;();
        Set&lt;String&gt; setAns = new HashSet&lt;String&gt;();
        for(int i = 0; i &lt;= s.length() - L; i++)&#123;
            String str = s.substring(i,i+L);
            if(setStr.contains(str))&#123;
                setAns.add(str);
            &#125;else&#123;
                setStr.add(str);
            &#125;
        &#125;
        List&lt;String&gt; listString = new ArrayList&lt;String&gt;();
        for(String ans : setAns)&#123;
            listString.add(ans);
        &#125;
        return listString;
    &#125;
&#125;
</code></pre>
<p>结果：</p>
<p><img src="/2021/10/09/LeetCodeDaily/187.png"></p>
<blockquote>
<p>官解给的方法一写的更巧妙，可以去看看</p>
</blockquote>
<h2 id="352-将数据流变为多个不相交区间"><a href="#352-将数据流变为多个不相交区间" class="headerlink" title="352. 将数据流变为多个不相交区间"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/data-stream-as-disjoint-intervals/">352. 将数据流变为多个不相交区间</a></h2><p>思路：</p>
<p>用一个boolean的数组维护数据流输入情况</p>
<p>用两个哨兵first和last来判断连续的区间情况并将存入到一个ArrayList中</p>
<p>最后将ArrayList类型转换为一个二维数组return即可</p>
<pre><code class="Java">class SummaryRanges &#123;
    static final int NUM = 10001;
    public boolean[] arr = new boolean[NUM];
    public SummaryRanges() &#123;
    &#125;
    public void addNum(int val) &#123;
        arr[val] = true;
    &#125;
    public int[][] getIntervals() &#123;
        List&lt;int[]&gt; res = new ArrayList&lt;int[]&gt;();
        int first = -1;
        int last = -1;
        for(int i = 0 ;i &lt;= 10000;i++)&#123;
            if(arr[i])&#123;
                if(first == -1)&#123;
                    first = i;
                    last = i;
                &#125;else last = i;
            &#125;else&#123;
                if(first != -1)&#123;
                    res.add(new int[]&#123;first,last&#125;);
                    first = -1;
                    last = -1;
                &#125;
            &#125;
        &#125;
        if(first != -1)&#123;
             res.add(new int[]&#123;first,last&#125;);
        &#125;
        return res.toArray(new int[res.size()][2]);
    &#125;
&#125;
</code></pre>
<p>时间复杂度：<code>addNum()</code> 为 O(1)<em>O</em>(1)，<code>getIntervals()</code> 为 O(C)，C 固定为10001。</p>
<p>空间复杂度：O(C)，C 固定为10001。</p>
<p>结果如图：</p>
<p><img src="/2021/10/09/LeetCodeDaily/352.png"></p>
<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h2><p>思路：</p>
<p>刚开始直接暴力法，时间复杂度为<strong>O(N3)</strong>,还得考虑去重的步骤，看了题解不如直接使用<strong>排序+双指针</strong>，能将时间复杂度降到O(N2)</p>
<p>先将数组排序，时间复杂度<strong>O(NlogN)</strong></p>
<p>然后固定数组最左端指针<code>i</code>，在<code>i</code>右端使用两个动态指针<code>j、k</code>移动，将三数之和与零进行比较：</p>
<ul>
<li>等于零时，将结果添加进List集合中，然后<code>j</code>指针向右移，<code>k</code>指针向左移</li>
<li>大于零时，<code>k</code>指针向左移且去重</li>
<li>小于零时，<code>j</code>指针向右移动且去重</li>
</ul>
<p>代码：</p>
<pre><code class="java">class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;
        Arrays.sort(nums);
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList();
        int length = nums.length;
        for(int i = 0 ; i &lt; length-2; i++)&#123;
            if(nums[i] &gt; 0) break;
            if(i&gt;0 &amp;&amp; nums[i] == nums[i-1]) continue;
            int j = i+1; //左指针
            int k = length-1; //右指针
            while(j&lt;k)&#123;
                int total = nums[i] + nums[j] + nums[k];
                if(total&gt;0)&#123;
                    //去重且向左移
                    while(j&lt;k &amp;&amp; nums[k] == nums[--k]);
                &#125;else if(total&lt;0)&#123;
                    //去重且向右移
                    while(j&lt;k &amp;&amp; nums[j] == nums[++j]);
                &#125;else &#123;
                    res.add(new ArrayList&lt;Integer&gt;(Arrays.asList(nums[i],nums[j],nums[k])));
                    while(j&lt;k &amp;&amp; nums[k] == nums[--k]);
                    while(j&lt;k &amp;&amp; nums[j] == nums[++j]);
                &#125;
            &#125;   
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<p>时间复杂度： <strong>O(N2)<strong>，固定指针<code>i</code>复杂度</strong>O(N)</strong>,动态双指针<code>i</code>、<code>j</code>**O(N)**的复杂度</p>
<p>空间复杂度：**O(1)**，指针占用常数大小空间</p>
<p>结果如图：</p>
<p><img src="/2021/10/09/LeetCodeDaily/15.png"></p>
<blockquote>
<p>代码中最令人感叹的是指针去重且移动的操作：</p>
<p>如：<code>while(j&lt;k &amp;&amp; nums[k] == nums[--k]);</code></p>
<p>每次看大佬题解都感觉受益匪浅</p>
</blockquote>
<h2 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h2><p>思路：</p>
<ul>
<li>模拟填入过程：<ul>
<li>设立<strong>上下左右</strong>四个边界，上、左边界初始值为0，右、下边界初始值为n-1</li>
<li>始终按照四个方向：从左到右、从上到下、从右到左、从下到上<ul>
<li>填入数字达到边界后，对应的边界向内缩小</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="Java">class Solution &#123;
    public int[][] generateMatrix(int n) &#123;
        int[][] res = new int[n][n];
        int count = 1,num = n * n;
        int left = 0,top = 0,right = n-1,down = n-1; //左上右下四个边界
        while(count &lt;= num)&#123;
            for(int i =left;i &lt;= right;i++) res[top][i] = count++;//左边界left到右边界right，top行填完后top++
            top++;
            for(int i =top;i &lt;= down;i++) res[i][right] = count++;//上边界top到下边界down，right列填完后right--
            right--;
            for(int i =right;i &gt;= left;i--) res[down][i] = count++;//右边界right到左边界left，down行填完后down--
            down--;
            for(int i =down;i &gt;= top;i--) res[i][left] = count++;//下边界down到上边界top，left列填完后left++
            left++;
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<p>运行结果：<br><img src="/2021/10/09/LeetCodeDaily/59.png"></p>
<h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a></h2><p>思路：</p>
<ul>
<li>按照数组右区间大小升序排序，参考大佬<strong>代码随想录</strong>的一张图：<img src="/2021/10/09/LeetCodeDaily/435_1.png"><ul>
<li>使用右区间最小数组1依次向右判断，当达到数组4时符合条件<code>count++</code>,此时从数组4继续向右判断</li>
</ul>
</li>
<li>根据条件判断出符合条件的区间数量<code>count</code>，则剩下的就是需要移除的区间数量</li>
</ul>
<pre><code class="java">class Solution &#123;
    public int eraseOverlapIntervals(int[][] intervals) &#123;
        if(intervals.length == 0) return 0;
        Arrays.sort(intervals,(a,b) -&gt; a[1] - b[1]);
        int count = 1;
        int num = intervals[0][1];
        for(int i = 1 ;i &lt; intervals.length; i++)&#123;
            if(num &lt;= intervals[i][0])&#123;
                num = intervals[i][1];
                count++;
            &#125;
        &#125;
        return intervals.length - count;
    &#125;
&#125;
</code></pre>
<p>时间复杂度：<strong>O(nlogn)</strong>,有一个快排</p>
<p>空间复杂度：<strong>O(1)</strong></p>
<p>结果如图：<br><img src="/2021/10/09/LeetCodeDaily/435_2.png"></p>
<h2 id="29-两数相除"><a href="#29-两数相除" class="headerlink" title="29. 两数相除"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/divide-two-integers/">29. 两数相除</a></h2><p>思路：</p>
<ul>
<li>减法，被除数循环减去除数，但是效率比较低<ul>
<li>位运算，计算机进行位运算时的效率比较高，通过右位移找出满足**<code>2^i</code><em>除数&lt;=被除数*<em>最大的<code>i</code>,此时被除数减去</em></em><code>2^i</code>*除数**，再找剩下满足条件的<code>i</code>,以此类推</li>
<li>举个例子，100/6—&gt; <em><em><code>2^4</code><em>6&lt;=100</em></em>,此时最大的<code>i</code>是4,剩下的100-96 = 4无法满足</em><em><code>2^i</code><em>除数&lt;=被除数</em></em>,则商为16</li>
</ul>
</li>
</ul>
<p>代码：</p>
<pre><code class="java">class Solution &#123;
    public int divide(int dividend, int divisor) &#123;
        if(dividend == 0) return 0;
        if(dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1) return Integer.MAX_VALUE;
        boolean negative = (dividend ^ divisor) &lt; 0;//符号判断
        int res = 0;
        long num1 = Math.abs((long)dividend);
        long num2 = Math.abs((long)divisor);
        for(int i = 31 ; i &gt;= 0 ; i--)&#123; 
            if((num1 &gt;&gt; i) &gt;= num2)&#123; //找出最大的数divisor*2^n
                res += 1&lt;&lt;i;         //结果加上2^n
                num1 -= num2&lt;&lt;i;     //计算剩余被除数
            &#125;
        &#125;
        return negative ? -res:res;  //符号互异取反
    &#125;
&#125;
</code></pre>
<p>结果：</p>
<p><img src="/2021/10/09/LeetCodeDaily/29.png"></p>
<h2 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38. 外观数列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-and-say/">38. 外观数列</a></h2><p>思路：</p>
<ul>
<li><p>使用双指针，截取<strong>相同字符</strong>的每个组，按照题意模拟即可</p>
<ul>
<li>依次遍历每个组</li>
<li>依次填入<code>n</code>(指针下标<strong>相减</strong>)个<code>m</code>（填入<strong>first</strong>指针的数）</li>
<li>进行下一次遍历</li>
</ul>
</li>
</ul>
<p>代码：</p>
<pre><code class="java">class Solution &#123;
    public String countAndSay(int n) &#123;
        String str = &quot;1&quot;;
        for(int i = 2; i &lt;= n ; i++)&#123;
            int first = 0 ,last = 0;
            StringBuffer sb = new StringBuffer();
            while(last &lt; str.length())&#123;
                while(last &lt; str.length() &amp;&amp; str.charAt(first) == str.charAt(last)) last++;
                sb.append(Integer.toString(last - first)).append(str.charAt(first));
                first = last;
            &#125;
            str = sb.toString();
        &#125;
        return str;
    &#125;
&#125;
</code></pre>
<p>结果：</p>
<p><img src="/2021/10/09/LeetCodeDaily/38.png"></p>
<p>时间复杂度：O(N*M),N-&gt;给定正整数n，M-&gt;生成字符串长度</p>
<p>空间复杂度：O(M)，M-&gt;生成字符串长度</p>
<h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-labels/">763. 划分字母区间</a></h2><p>思路：</p>
<ul>
<li>最难的是如何划分好符合条件的片段<ul>
<li>先用一个<strong>数组</strong>记录每个字母的最远下标(也可以用<strong>HashMap</strong>来记录)</li>
<li>用两个下标截取片段<ul>
<li>当前遍历字母的最远下标一定是在当前片段中，即<code>end</code>大于等于当前字母的最远下标</li>
<li>当遍历<code>i</code>访问到下标<code>end</code>时，这个片段即是符合条件的片段(贪心)</li>
</ul>
</li>
<li>将当前片段结果加入结果集，进行后续片段的遍历</li>
</ul>
</li>
</ul>
<p>代码：</p>
<pre><code class="java">class Solution &#123;
    public List&lt;Integer&gt; partitionLabels(String s) &#123;
        int len = s.length();
        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
        int[] arr = new int[26];
        for(int i = 0 ; i &lt; len ; i++)&#123;
            arr[s.charAt(i) - &#39;a&#39;] = i; //记录字母最远下标
        &#125; 
        int start = 0, end = 0;
        for(int i = 0 ; i &lt; len ; i++)&#123;
            end = Math.max(end,arr[s.charAt(i) - &#39;a&#39;]); //当前遍历字母的最远下标一定是在当前片段中
            if(i == end)&#123;
                res.add(end - start + 1);
                start = end + 1;
            &#125;
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<p>结果：</p>
<p><img src="/2021/10/09/LeetCodeDaily/763.png"></p>
<p>时间复杂度：log(N),遍历两次数组</p>
<p>空间复杂度：log(m),m是字符串中的字符集，这题中m为26(只包含26个小写字母)</p>
<blockquote>
<p>Tips：</p>
<p>对于贪心的思想掌握的还是不够好，以局部最优求出全局最优。</p>
</blockquote>
<h2 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/multiply-strings/">43. 字符串相乘</a></h2><p>思路：</p>
<p>将乘数每一位和被乘数<strong>相乘累加</strong>的结果放入对应数组中，乘数和被乘数长度分别为<code>en1</code>和<code>len2</code>，故数组的大小不超过<strong>len1+len2</strong>（例如100 * 100 = 1000，3 + 3 &gt;= 4 ）</p>
<ul>
<li>两个for循环得到结果数组后，还得对数组进行操作才能获得最终数组(模拟乘法)<ul>
<li>数组下标从右到左，将当前数组下标的值与10除<strong>取商</strong>累加到左一位</li>
<li>当前数组下标与10除<strong>取余</strong></li>
</ul>
</li>
<li>获得最终数组后，判断数组arr[0]为0或1进行字符串拼接操作（题目要求不以0开头）</li>
</ul>
<p>代码：</p>
<pre><code class="java">class Solution &#123;
    public String multiply(String num1, String num2) &#123;
        if(num1.equals(&quot;0&quot;) || num2.equals(&quot;0&quot;)) return &quot;0&quot;;
        
        int len1 = num1.length(),len2 = num2.length();
        int[] arr = new int[len1 + len2];

        for(int i = len1 - 1; i &gt;= 0; i--)&#123;
            int curnum1 = num1.charAt(i) - &#39;0&#39;;
            for(int j = len2 - 1; j &gt;= 0; j--)&#123;
                int curnum2 = num2.charAt(j) - &#39;0&#39;;
                arr[i + j + 1] += curnum1 * curnum2;
            &#125;
        &#125;

        for(int k = len1 + len2 -1 ; k &gt; 0; k--)&#123;
            arr[k - 1] += arr[k]/10;
            arr[k] %= 10;
        &#125;

        int index = arr[0] == 0 ? 1 : 0;
        StringBuffer res = new StringBuffer();
        while(index &lt; len1 + len2)&#123;
            res.append(arr[index]);
            index++;
        &#125;
        return res.toString();
    &#125;
&#125;
</code></pre>
<p>结果：</p>
<p><img src="/2021/10/09/LeetCodeDaily/43.png"></p>
<p>时间复杂度：<strong>O(m*n)</strong>,其中<code>m</code>和<code>n</code>分别是<code>num1</code>和<code>num2</code>的长度</p>
<p>空间复杂度：**O(m+n)**，</p>
<h2 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h2><p>思路：</p>
<p>因为是二叉搜索树，所以可以用栈按中序遍历来访问二叉树</p>
<p>代码：</p>
<pre><code class="java">class Solution &#123;
    public int kthSmallest(TreeNode root, int k) &#123;
        Deque&lt;TreeNode&gt; stk = new LinkedList&lt;&gt;();
        while(root != null|| !stk.isEmpty())&#123;
            while(root != null)&#123;
                stk.push(root);
                root = root.left;
            &#125;
            root = stk.pop();
            k--;
            if( k == 0 )&#123;
                break;
            &#125;
            root = root.right;
        &#125;
        return root.val;
    &#125;
&#125;
</code></pre>
<p>结果：</p>
<p><img src="/2021/10/09/LeetCodeDaily/230.png"></p>
<p>时间复杂度：<code>O(H+k)</code>,H是树的高度,当树是平衡树时，可以取<code>O(logN+k)</code></p>
<p>空间复杂度：<code>O(H)</code>,栈中最多存H个元素</p>
<blockquote>
<p>Tips;</p>
<p>记录这题的目的是自从学习数据结构后很久没做树的题目了，最近开始刷题时遇到的第一道树的题目，故记录下来。</p>
</blockquote>
<h2 id="211-添加与搜索单词-数据结构设计"><a href="#211-添加与搜索单词-数据结构设计" class="headerlink" title="211. 添加与搜索单词 - 数据结构设计"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/">211. 添加与搜索单词 - 数据结构设计</a></h2><p>思路：</p>
<p>简单暴力的方法</p>
<ul>
<li>用<strong>HashMap</strong>存**<code>键：值</code><strong>为</strong><code>字符串长度：相同长度下不同的单词</code>**</li>
<li>查找的时候，从<strong>HashMap</strong>取出相同长度下的<strong>set集合</strong><ul>
<li>先考虑不带 <code>&#39;.&#39;</code>的单词</li>
<li>对于含有 <code>&#39;.&#39;</code>的单词再拆放入数组中逐个比较</li>
</ul>
</li>
</ul>
<p>代码：</p>
<pre><code class="java">class WordDictionary &#123;
    Map&lt;Integer,Set&lt;String&gt;&gt; map = new HashMap&lt;&gt;();//根据字符串长度分开存放
    public WordDictionary() &#123;
        
    &#125;
    public void addWord(String word) &#123;
        int len = word.length();
        if(map.get(len) != null)&#123;
            map.get(len).add(word);
        &#125;else&#123;
            Set&lt;String&gt; set = new HashSet&lt;&gt;();
            set.add(word);
            map.put(len,set);
        &#125;
    &#125;
    public boolean search(String word) &#123;
        Set&lt;String&gt; set = map.get(word.length());
      
        if(set == null) return false;
        if(set.contains(word)) return true;
      
        char[] charword = word.toCharArray(); 
        P:for(String str : set)&#123;
            if(str.length() != word.length()) continue;
            char[]  charstr = str.toCharArray();
            for(int i = 0 ; i &lt; word.length(); i++)&#123; //每个字符比较
                if(charword[i] != &#39;.&#39; &amp;&amp; charword[i] != charstr[i]) continue P; //遍历下一个字符
            &#125;
            return true;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<p>结果：</p>
<p><img src="/2021/10/09/LeetCodeDaily/211.png"></p>
<blockquote>
<p>该题的官方解法是使用前缀树进行求解</p>
</blockquote>
<h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串</a></h2><p>思路：</p>
<p>回文字符串，可以按照<strong>回文中心向两侧延伸</strong>的思路来查找有多少个回文字符串</p>
<ul>
<li>回文中心，按照奇偶的区分来说，回文中心不是单个字符就是两个同样的字符如<code>a</code>或<code>aa</code>,当三个字符的情况可以视作为一个回文串</li>
<li>其次，回文中心的数量按照观察来说，有<code>2*len-2</code>个(其中len为字符串长度)</li>
<li>最后可以定义两个指针向两侧延伸<ul>
<li>当回文中心为奇数时，两指针重叠</li>
<li>当回文中心为偶数时，两指针一左一右</li>
</ul>
</li>
</ul>
<p>代码：</p>
<pre><code class="java">class Solution &#123;
    public int countSubstrings(String s) &#123;
        int len = s.length(), ans = 0;
        for (int i = 0; i &lt; 2 * len - 1; ++i) &#123;
            int l = i / 2, r = i / 2 + i % 2;
            while (l &gt;= 0 &amp;&amp; r &lt; len &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;
                --l;
                ++r;
                ++ans;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;
</code></pre>
<p>结果：</p>
<p><img src="/2021/10/09/LeetCodeDaily/647.png"></p>
<p>时间复杂度：<strong>O(n^2)</strong>,枚举回文中心<strong>O(n)</strong>,指针延展查找回文子串<strong>O(n)</strong></p>
<p>空间复杂度：<strong>O(1)</strong></p>
<h2 id="229-求众数-II"><a href="#229-求众数-II" class="headerlink" title="229. 求众数 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element-ii/">229. 求众数 II</a></h2><p>先放上代码</p>
<pre><code class="Java">class Solution &#123;
    public List&lt;Integer&gt; majorityElement(int[] nums) &#123;
        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        int count = 0,len = nums.length;
        for(int num : nums)&#123;
            map.put(num,map.getOrDefault(num,0)+1);
        &#125;
        for (Integer key : map.keySet()) &#123;
            if(map.get(key) &gt; len/3) res.add(key);
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<p>这是时间复杂度和空间复杂度均为**O(n)**的解法,其中<code>n</code>为数组的长度</p>
<p>但是题目的进阶要求是把空间复杂度优化到<strong>O(1)</strong>,题解给了一种很神奇的方法——<strong>摩尔投票法</strong>,思路如下：</p>
<ul>
<li><p>题目要求找出超过【n/3】的元素，实际上隐含了一个条件——结果集内只有两个结果</p>
</li>
<li><p>大致cv一下摩尔投票法的思路</p>
<ul>
<li>选票数超过一半的候选人时，投票结果如数组【A,B,C,C,C,A】</li>
<li>第一张票和第二张票不同，分别为A和B，互相抵消</li>
<li>第三四五张票相同，则增加C候选人可以抵消的票数</li>
<li>后面还有一张A抵消C一次，此时候选人是C，则统计一下C在数组中出现的次数，超过一半则候选人是C</li>
</ul>
</li>
<li><p>可以看出摩尔投票法是一个抵消的思路，同时由票数<strong>超过1/2即被选取</strong>扩展一下至票数<strong>超过1/n时被选取</strong>，则最理想情况下会有<strong>n-1个被选取</strong></p>
</li>
</ul>
<p>贴上代码：</p>
<pre><code class="java">class Solution &#123;
    public List&lt;Integer&gt; majorityElement(int[] nums) &#123;
        // 创建返回值
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        if (nums == null || nums.length == 0) return res;
        // 初始化两个候选人candidate，和他们的计票
        int cand1 = nums[0], count1 = 0;
        int cand2 = nums[0], count2 = 0;

        // 摩尔投票法，分为两个阶段：配对阶段和计数阶段
        // 配对阶段
        for (int num : nums) &#123;
            // 投票
            if (cand1 == num) &#123;
                count1++;
                continue;
            &#125;
            if (cand2 == num) &#123;
                count2++;
                continue;
            &#125;

            // 第1个候选人配对
            if (count1 == 0) &#123;
                cand1 = num;
                count1++;
                continue;
            &#125;
            // 第2个候选人配对
            if (count2 == 0) &#123;
                cand2 = num;
                count2++;
                continue;
            &#125;

            count1--;
            count2--;
        &#125;

        // 计数阶段
        // 找到了两个候选人之后，需要确定票数是否满足大于 N/3
        count1 = 0;
        count2 = 0;
        for (int num : nums) &#123;
            if (cand1 == num) count1++;
            else if (cand2 == num) count2++;
        &#125;

        if (count1 &gt; nums.length / 3) res.add(cand1);
        if (count2 &gt; nums.length / 3) res.add(cand2);

        return res;
    &#125;
&#125;
</code></pre>
<p>时间复杂度依然是**O(n),<strong>但是空间复杂度已经只有</strong>O(1)**了</p>
<h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h2><blockquote>
<p>很经典的一道题，记录一下</p>
</blockquote>
<p>思路</p>
<p>官解说可以用<strong>Hashmap</strong>来存储中序遍历数组的下标，这样在后续递归中，中序遍历数组，定位根节点位置时时间复杂度只有O(1)，真是妙蛙种子吃着妙脆角妙进了米奇妙妙屋，妙到家了～</p>
<ul>
<li><p>根据<strong>先序遍历</strong>数组的<strong>第一位</strong>判断为根节点</p>
</li>
<li><p>根据根节点判断<strong>中序遍历</strong>的左子树和右子树</p>
<ul>
<li><p>递归传入下标时，注意子树左右边界：</p>
<ul>
<li><p>很显然中序遍历数组中查找到根节点后<strong>其左右分别是左右子树的区间</strong></p>
</li>
<li><p>先序遍历数组中<strong>最左下标对应的为根节点</strong>，根据中序遍历左侧数组下标来求得<strong>左子树数量</strong>，同理求得右<strong>子树数量</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>代码</p>
<pre><code class="java">class Solution &#123;
    Map&lt;Integer,Integer&gt; res = new HashMap&lt;&gt;();
    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;
        for(int i = 0 ; i &lt; inorder.length; i++)&#123;
            res.put(inorder[i],i); 
        &#125; 

        return makeTree(preorder,inorder,0,preorder.length - 1,0,inorder.length - 1);

    &#125;

    public TreeNode makeTree(int[] preorder, int[] inorder, int pre_left,int pre_right,int in_left,int in_right)&#123;

        if(pre_left &gt; pre_right) return null;
        //先序遍历数组的第一位即是根节点
        int pre_root = pre_left;

        //在中序遍历中定位根节点
        int in_root = res.get(preorder[pre_root]);

        //建立根节点
        TreeNode root = new TreeNode((preorder[pre_root]));

        //中序遍历数组根节点的左侧 -&gt; 得到左子树中节点的数目
        int size_left_subtree = in_root - in_left;

        //递归构造左子树
        root.left = makeTree(preorder,inorder,pre_left + 1,pre_left + size_left_subtree ,in_left,in_right - 1);

        //递归构造右子树
        root.right = makeTree(preorder,inorder,pre_left + size_left_subtree + 1,pre_right,in_root + 1,in_right);

        return root;
    &#125;
&#125;
</code></pre>
<p>时间复杂度：<strong>O(n)</strong>,n为树中节点的个数</p>
<p>空间复杂度：**O(n)**，n为HashMap的空间+返回结果的空间+递归时栈空间(树高度)</p>
<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><blockquote>
<p>最经典的BFS了</p>
<p>之前学数据结构时用c++实现的，现在时隔很久，正式开始算法时用java实现</p>
</blockquote>
<p>思路</p>
<p>迭代方法：</p>
<p>用一个队列来维护当前层的节点，用一个list集合来维护当前层节点的值，每遍历一次队列后，再将list集合添加进最终结果集中</p>
<ul>
<li>用**队列(queue)**来存放当前层的节点</li>
<li>在遍历<strong>队列</strong>(节点)时,临时创建一个**集合(ArrayList)**来存放每一层节点的值</li>
</ul>
<p>代码</p>
<pre><code class="java">class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;
        if(root==null) &#123;
            return new ArrayList&lt;List&lt;Integer&gt;&gt;();
        &#125;
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); //存放结果集
        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); //存放结点
        //将根节点放入队列中
        queue.add(root);
        while(queue.size()&gt;0) &#123;
            //获取当前队列的长度，这个长度相当于 当前这一层的节点个数
            int size = queue.size();
            ArrayList&lt;Integer&gt; tmp = new ArrayList&lt;Integer&gt;();
            //将队列中的元素都拿出来(也就是获取这一层的节点)，放到临时list中
            //如果节点的左/右子树不为空，也放入队列中
            for(int i=0;i&lt;size;++i) &#123;
                TreeNode t = queue.remove();
                tmp.add(t.val);
                if(t.left!=null) &#123;
                    queue.add(t.left);
                &#125;
                if(t.right!=null) &#123;
                    queue.add(t.right);
                &#125;
            &#125;
            //将临时list加入最终返回结果中
            res.add(tmp);
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<p>时间复杂度：<strong>O(N)</strong></p>
<p>空间复杂度：<strong>O(h)</strong>,h是树的高度</p>
<h2 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h2><blockquote>
<p>记录这题的目的是因为相比于暴力法O(n^2)的时间复杂度，有一种优化方法——单调栈法，时间复杂度可以优化到O(n+m)，这种方法也是专门解这一类题目的优化解法</p>
</blockquote>
<p>思路</p>
<ul>
<li>用一个<strong>HashMap</strong>来记录<code>nums2</code>数组中每个数其右边第一个比它大的数字<ul>
<li>用一个栈来逆序遍历<code>nums2</code>，记录比<code>nums2[i]</code>大的数,逆序遍历存入栈时，离<code>nums2[i]</code>右边最近的数在栈顶<ul>
<li>这一步是<strong>单调栈法</strong>的精华，妙到我无法用<strong>精炼的文字</strong>来描述，题目要求左边更大的元素时，就可以顺序遍历</li>
</ul>
</li>
</ul>
</li>
<li>在<strong>HashMap</strong>中查看<code>nums1</code>对应的结果</li>
</ul>
<p>代码</p>
<pre><code class="java">class Solution &#123;
    public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123;
        int n = nums1.length, m = nums2.length;
        Deque&lt;Integer&gt; d = new ArrayDeque&lt;&gt;();
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int i = m - 1; i &gt;= 0; i--) &#123;
            int x = nums2[i];
            while (!d.isEmpty() &amp;&amp; d.peekLast() &lt;= x) d.pollLast(); //比nums2[i]小的元素出栈
            map.put(x, d.isEmpty() ? -1 : d.peekLast());
            d.addLast(x);
        &#125;
        int[] ans = new int[n];
        for (int i = 0; i &lt; n; i++) ans[i] = map.get(nums1[i]);
        return ans;
    &#125;
&#125;
作者：AC_OIer
链接：https://leetcode-cn.com/problems/next-greater-element-i/solution/gong-shui-san-xie-yi-ti-shuang-jie-bian-n6nwz/
来源：力扣（LeetCode）
</code></pre>
<blockquote>
<p>代码转载自三叶姐，问就是她的暴力法写的太优雅了，自愧不如</p>
</blockquote>
<p>时间复杂度：<strong>O(m+n)</strong>, **O(m)**维护单调栈+O(n)构造答案</p>
<p>空间复杂度：<strong>O(m)</strong></p>
<h2 id="869-重新排序得到-2-的幂"><a href="#869-重新排序得到-2-的幂" class="headerlink" title="869. 重新排序得到 2 的幂"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reordered-power-of-2/">869. 重新排序得到 2 的幂</a></h2><blockquote>
<p>记录这题的目的是，很多时候并没有想出一个很好的解题思路(简单or简洁)，可能是题量还不够，思路还没扩展开来</p>
</blockquote>
<p>思路：</p>
<p>直接暴力回溯的， 在范围内满足<code>2 的幂</code>的数字不多</p>
<p>但是匹配上写的方法很乱，这里放上一种很好的思路</p>
<p><strong>词频统计</strong></p>
<ul>
<li>提前找出符合范围内满足<code>2 的幂</code>的数字，遍历每一个数字时，将该数字转换为num[对应位数字]{该数字出现次数}<ul>
<li>把给定<code>正整数N</code>转换为num[对应位数字]{该数字出现次数}</li>
<li>两个数组进行匹配</li>
</ul>
</li>
</ul>
<p>代码：</p>
<pre><code class="java">class Solution &#123;
    Set&lt;Integer&gt; res = new HashSet&lt;&gt;();

    public boolean reorderedPowerOf2(int n) &#123;
        for(int i = 1 ; i&lt;= (int)1e9+10; i*=2)&#123;
            res.add(i);
        &#125;

        int[] cnt = new int[10];
        while(n != 0)&#123;
            cnt[n%10]++;
            n /= 10;
        &#125;

        lo:for(int num : res)&#123;
            int[] resCnt = new int[10];
            while(num != 0)&#123;
                resCnt[num%10]++;
                num /= 10;
            &#125;

            for(int i = 0 ; i &lt; 10; i++)&#123;
                if(cnt[i] != resCnt[i]) continue lo;
            &#125;
            return true;
        &#125;
        return false;

    &#125;
&#125;
</code></pre>
<p>时间复杂度： O(C∗logn)</p>
<p>空间复杂度：O(C),C为数组空间大小</p>
<h2 id="1218-最长定差子序列"><a href="#1218-最长定差子序列" class="headerlink" title="1218. 最长定差子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/">1218. 最长定差子序列</a></h2><p>思路</p>
<p>刚开始考虑使用<code>n^2</code>时间复杂度的暴力，一想可能会超时，遂打算用Hashmap来解决，但是自己对dp的学习还是不够深入，在转移方程上卡住了。。。</p>
<p>哈希表+DP</p>
<p>这题的关键是在于找到正确的转移方程：</p>
<ul>
<li><em>dp</em>[<em>v</em>]=<em>dp</em>[<em>v</em>−<em>d</em>]+1</li>
</ul>
<p>代码</p>
<blockquote>
<p>这里放的是官方的题解，问就是写的比我优雅简洁。。。</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    public int longestSubsequence(int[] arr, int difference) &#123;
        int ans = 0;
        Map&lt;Integer, Integer&gt; dp = new HashMap&lt;Integer, Integer&gt;();
        for (int v : arr) &#123;
            dp.put(v, dp.getOrDefault(v - difference, 0) + 1);
            ans = Math.max(ans, dp.get(v));
        &#125;
        return ans;
    &#125;
&#125;
</code></pre>
<p>时间复杂度：<em>O</em>(<em>n</em>)，其中 <em>n</em> 是数组 <em>arr</em> 的长度。</p>
<p>空间复杂度：<em>O</em>(<em>n</em>)。哈希表需要 O*(*n) 的空间。</p>
<h2 id="319-灯泡开关-数论"><a href="#319-灯泡开关-数论" class="headerlink" title="319. 灯泡开关 数论"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bulb-switcher/">319. 灯泡开关</a> 数论</h2><blockquote>
<p>很经典的数论题</p>
</blockquote>
<p>思路</p>
<p>首先，从约数下手，不难得出，约数为偶数的的灯泡，最后会熄灭，同理，约数为奇数的灯泡，最后会亮着。</p>
<p>然后，由约数的定义可得，对于数字<strong>k</strong>而言，如果他有约数x，那么一定有相对应的约数字<strong>y</strong>成对出现，使得<strong>k=x*y</strong>，同时，只有约数为<strong>「完全平方数」</strong>时，才会有<strong>奇数个</strong>的约数，否则则为<strong>偶数个</strong></p>
<p>举个🌰：</p>
<p>💡灯泡8⃣️的约数有：1、2、4、8，相对应的是-&gt;亮、灭、亮、灭</p>
<p>💡灯泡9⃣️的约数有：1、3、9，相对应的是-&gt;亮、灭、亮</p>
<p>最后，就是求给定n的约数，考虑到开方，结果向下取整。</p>
<p>代码</p>
<pre><code class="Java">class Solution &#123;
    public int bulbSwitch(int n) &#123;
        return (int)Math.floor(Math.sqrt(n));
    &#125;
&#125;
</code></pre>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(1)</p>
<h2 id="1143-最长公共子序列-动态规划"><a href="#1143-最长公共子序列-动态规划" class="headerlink" title="1143. 最长公共子序列 动态规划"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a> 动态规划</h2><p>思路</p>
<p>二维数组+DP</p>
<p>状态定义：<code>dp[i][j]</code>代表考虑text1 前<code>i</code>个字符、考虑text2前<code>j</code>个字符</p>
<p>那么对于「转移方程」来说</p>
<ul>
<li>当字符串<code>cs1[i] == cs[j]</code>：<code>dp[i][j] == dp[i-1][j-1] +1</code></li>
<li>当字符串<code>cs1[i] != cs[j]</code>：<code>dp[i][j]=max(dp[i][j-1],dp[i-1][j])</code></li>
</ul>
<blockquote>
<p>这里放一张官解的图</p>
</blockquote>
<p><img src="/2021/10/09/LeetCodeDaily/1143.png"></p>
<p>代码</p>
<pre><code class="java">class Solution &#123;
    public int longestCommonSubsequence(String text1, String text2) &#123;
        int n = text1.length(), m = text2.length();
        char[] cs1 = text1.toCharArray();
        char[] cs2 = text2.toCharArray();
        int[][] dp = new int[n + 1][m + 1];
        for(int i = 1; i &lt;= n;i++)&#123;
            for(int j = 1 ;j &lt;= m; j++)&#123;
                if(cs1[i-1] == cs2[j-1]) dp[i][j] = dp[i-1][j-1] + 1;
                else dp[i][j] = Math.max(dp[i][j-1],dp[i-1][j]); 
            &#125;
        &#125;
        return dp[n][m];
    &#125;
&#125;
</code></pre>
<p>时间复杂度：O(n * m)</p>
<p>空间复杂度：O(n * m)</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>ZZGuo
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://www.superzzguo.com/2021/10/09/LeetCodeDaily/" title="LeetCode每日亿题">http://www.superzzguo.com/2021/10/09/LeetCodeDaily/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LeetCode/" rel="tag"># LeetCode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/02/Go/" rel="prev" title="Golang入门">
      <i class="fa fa-chevron-left"></i> Golang入门
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/10/15/Mysql_LeftmostMatchingPrinciple/" rel="next" title="Mysql最左匹配原则">
      Mysql最左匹配原则 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#LeetCode%E6%AF%8F%E6%97%A5%E4%BA%BF%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">LeetCode每日亿题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#187-%E9%87%8D%E5%A4%8D%E7%9A%84DNA%E5%BA%8F%E5%88%97"><span class="nav-number">1.1.</span> <span class="nav-text">187. 重复的DNA序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#352-%E5%B0%86%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8F%98%E4%B8%BA%E5%A4%9A%E4%B8%AA%E4%B8%8D%E7%9B%B8%E4%BA%A4%E5%8C%BA%E9%97%B4"><span class="nav-number">1.2.</span> <span class="nav-text">352. 将数据流变为多个不相交区间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">1.3.</span> <span class="nav-text">15. 三数之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-II"><span class="nav-number">1.4.</span> <span class="nav-text">59. 螺旋矩阵 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="nav-number">1.5.</span> <span class="nav-text">435. 无重叠区间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4"><span class="nav-number">1.6.</span> <span class="nav-text">29. 两数相除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97"><span class="nav-number">1.7.</span> <span class="nav-text">38. 外观数列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"><span class="nav-number">1.8.</span> <span class="nav-text">763. 划分字母区间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#43-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98"><span class="nav-number">1.9.</span> <span class="nav-text">43. 字符串相乘</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">1.10.</span> <span class="nav-text">230. 二叉搜索树中第K小的元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#211-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.11.</span> <span class="nav-text">211. 添加与搜索单词 - 数据结构设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-number">1.12.</span> <span class="nav-text">647. 回文子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#229-%E6%B1%82%E4%BC%97%E6%95%B0-II"><span class="nav-number">1.13.</span> <span class="nav-text">229. 求众数 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.14.</span> <span class="nav-text">105. 从前序与中序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.15.</span> <span class="nav-text">102. 二叉树的层序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I"><span class="nav-number">1.16.</span> <span class="nav-text">496. 下一个更大元素 I</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#869-%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B0-2-%E7%9A%84%E5%B9%82"><span class="nav-number">1.17.</span> <span class="nav-text">869. 重新排序得到 2 的幂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1218-%E6%9C%80%E9%95%BF%E5%AE%9A%E5%B7%AE%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">1.18.</span> <span class="nav-text">1218. 最长定差子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#319-%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3-%E6%95%B0%E8%AE%BA"><span class="nav-number">1.19.</span> <span class="nav-text">319. 灯泡开关 数论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">1.20.</span> <span class="nav-text">1143. 最长公共子序列 动态规划</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->



      <div class="site-overview-wrap sidebar-panel">

        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZZGuo"
      src="/images/head.jpeg">
  <p class="site-author-name" itemprop="name">ZZGuo</p>
  <div class="site-description" itemprop="description">饮茶先啦</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Super-ZZGuo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Super-ZZGuo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>




      </div>

      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86
        src="//music.163.com/outchain/player?type=2&id=65592&auto=1&height=66">
      </iframe>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZZGuo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":true},"log":false});</script></body>
</html>
