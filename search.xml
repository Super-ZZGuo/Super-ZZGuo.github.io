<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>集合框架之HashMap&amp;HashSet源码阅读</title>
    <url>/2021/12/01/Collections-HashMap/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><em>HashMap</em>实现了<em>Map</em>接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素。</p>
<span id="more"></span>
<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p><em>HashMap</em>实现了<em>Map</em>接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素。</p>
<p>除该类未实现同步外，其余跟<code>Hashtable</code>大致相同；</p>
<p>跟<em>TreeMap</em>不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个<em>HashMap</em>的顺序可能会不同。</p>
<h1 id="HashMap的实现"><a href="#HashMap的实现" class="headerlink" title="HashMap的实现"></a>HashMap的实现</h1><h2 id="HashMap的底层数据结构"><a href="#HashMap的底层数据结构" class="headerlink" title="HashMap的底层数据结构"></a>HashMap的底层数据结构</h2><p>相比于JDK7的数组+链表的方式</p>
<p>JDK8中采用了<code>数组+链表+红黑树</code>的方式来构造一个HashMap</p>
<p><img src="/2021/12/01/Collections-HashMap/HashMap_1.png"></p>
<p>JDK8中，当链表的一个节点上的元素达到8个的时候，会将链表结构转换为<code>红黑树</code></p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>HashMap默认构造容量是16</p>
<blockquote>
<p>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;</p>
</blockquote>
<pre><code class="java">public HashMap(int initialCapacity) &#123;
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    &#125;
</code></pre>
<pre><code class="java">public HashMap() &#123;
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    &#125;
</code></pre>
<pre><code class="java">public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        putMapEntries(m, false);
    &#125;
</code></pre>
<p>其中，<code>DEFAULT_LOAD_FACTOR</code>也被称为负载因子，默认是<strong>0.75f</strong>。</p>
<blockquote>
<pre><code class="java">static final float DEFAULT_LOAD_FACTOR = 0.75f;
</code></pre>
</blockquote>
<p>负载因子是衡量哈希表在容量自动增加之前允许其达到多大的度量。当散列表中的条目数量超过负载因子和当前容量的乘积时，将重处理散列表（即重建内部数据结构），使散列表的桶数约为两倍。</p>
<p>至于为什么是0.75而不是其他，呵呵，JDK里说是泊松定律得出的0.7-0.8之间冲突最小？作为一名学习过概率论的大学僧，我也不记得了。。。</p>
<p>这里可以参考一下<code>StackOverFlow</code>的一个回答，大意是，桶空和非空的机率是0.5，由牛顿二项性可以知道，0.75更接近于log2(0.69)，可能负载因子在0.69-0.75性能会更好，但是0.75也不是不行(可能是考虑到位运算效率比较高)</p>
<p>![截屏2021-11-30 下午11.50.14](/Users/kokorozashiguohuang/Library/Application Support/typora-user-images/截屏2021-11-30 下午11.50.14.png)</p>
<p>总结，负载因子太小了浪费空间并且会发生更多次数的resize，太大了哈希冲突增加会导致性能不好(增加了查找的开销)</p>
<h2 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h2><h3 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h3><pre><code class="java">public V put(K key, V value) &#123;
        return putVal(hash(key), key, value, false, true);
    &#125;
        //第一个参数hash(key)，获得key对应的哈希值，当key为null时，哈希值为0
    //第二、三个参数为存储的键值对
    //第四个参数onlyIfAbsent如果是 true，那么只有在不存在该 key 时才会进行 put 操作
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &#123;
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        //如果是哈希表第一次put值，会触发resize()来初始化数组长度
        //第一次resize数组初始化到 16 OR 自定义容量 的大小
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        //找到数组下标，如果该位置为空，则放入Node节点
        // p为对应数组位置的链表节点
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        //该位置不为空
        else &#123;
            // e为辅助节点，用来记录key值与新插入节点相同的旧节点
            Node&lt;K,V&gt; e; K k;
            //判断该链表第一个节点和我们要插入的key是否相同，相同则取出该节点
            //PS：之前就听说过HashMap的put会更新key对应的value值
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            //如果该节点为红黑树节点，则调用红黑树的插入方法
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            //此时，可以说明该位置上是一个链表(位置不为空且不满足上述判断)
            else &#123;
                //遍历链表
                for (int binCount = 0; ; ++binCount) &#123;
                    //插入到链表的结尾(JDK7中是插入到链表的头部)
                    if ((e = p.next) == null) &#123;
                        p.next = newNode(hash, key, value, null);
                        //TREEIFY_THRESHOLD为8，当插入节点后该数组链表节点为8时
                        // 会使用treeifyBin将该链表转换为红黑树
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    &#125;
                    //当遍历到相同key值的节点时，直接break
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    //此时e为链表中与新插入节点node的key相等的旧节点
                    p = e;
                &#125;
            &#125;
            //e不为null，说明存在key相等的旧节点
            if (e != null) &#123; // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    //用新的value覆盖旧节点的value
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            &#125;
        &#125;
        ++modCount;
        //如果 HashMap在插入该节点后超出了阈值，则会进行扩容
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    &#125;
</code></pre>
<blockquote>
<p>关于第五个参数 evict，在出现了一下，查阅一下博客了解到，afterNodeInsertion方法的evict参数如果为false，表示哈希表处于创建模式。只有在使用Map集合作为构造器创建LinkedHashMap或HashMap时才会为false，使用其他构造器创建的LinkedHashMap，之后再调用put方法，该参数均为true。</p>
</blockquote>
<blockquote>
<p>这里put()方法对于辅助节点p、e的使用有无法描述的感觉。。。</p>
</blockquote>
<blockquote>
<p>JDK7是先判断是否要扩容再插入，JDK8是先插入再判断是否要扩容，但是都无关大雅了。。。</p>
</blockquote>
<h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><pre><code class="java">public V get(Object key) &#123;
        Node&lt;K,V&gt; e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    &#125;

    final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
            (first = tab[(n - 1) &amp; hash]) != null) &#123;
            //当第一个节点就是所需要的节点时，直接return
            if (first.hash == hash &amp;&amp; // always check first node
                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
                return first;
            if ((e = first.next) != null) &#123;
                //当判断第一个节点是红黑树节点时，调用红黑树的get方法
                if (first instanceof TreeNode)
                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
                //遍历链表
                do &#123;
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        return e;
                &#125; while ((e = e.next) != null);
            &#125;
        &#125;
        return null;
    &#125;
</code></pre>
<blockquote>
<p>get相比于put的操作就是小儿科罢了。。。</p>
</blockquote>
<h3 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h3><p>数组扩容方法，在put()中提到过</p>
<blockquote>
<p>写注释之前，一看那么长就知道是一场大战了。。。</p>
</blockquote>
<pre><code class="java">final Node&lt;K,V&gt;[] resize() &#123;
        Node&lt;K,V&gt;[] oldTab = table;
        //旧数组容量
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        //旧数组阈值
        int oldThr = threshold;
        //新数组容量OR阈值
        int newCap, newThr = 0;
        //开始扩容
        if (oldCap &gt; 0) &#123;
            //当旧数组容量&gt;=最大容量时,将阈值扩大到最大容量大小
            //MAXIMUM_CAPACITY = 1 &lt;&lt; 30
            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;
                threshold = Integer.MAX_VALUE;
                return oldTab;
            &#125;
            //容量/阈值扩大一倍
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &lt;&lt; 1; // double threshold
        &#125;
        // 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候
        else if (oldThr &gt; 0) // initial capacity was placed in threshold
            newCap = oldThr;
        // 对应使用 new HashMap() 初始化后，第一次 put 的时候
        else &#123;               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        &#125;
        if (newThr == 0) &#123;
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        &#125;
        threshold = newThr;
        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)
        //初始化一个新数组
        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        table = newTab;
        //原数组为初始化数组时，到这里已经结束
        //遍历数组进行数据迁移
        if (oldTab != null) &#123;
            for (int j = 0; j &lt; oldCap; ++j) &#123;
                Node&lt;K,V&gt; e;
                if ((e = oldTab[j]) != null) &#123;
                    oldTab[j] = null;
                    //当该数组只有一个元素时，直接迁移这个元素
                    if (e.next == null)
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    //红黑树节点的迁移
                    else if (e instanceof TreeNode)
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    else &#123; // preserve order
                        //处理链表
                        // 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序
                        // loHead、loTail 对应一条链表的头尾，hiHead、hiTail 对应另一条链表头尾
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        do &#123;
                            next = e.next;
                            if ((e.hash &amp; oldCap) == 0) &#123;
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            &#125;
                            else &#123;
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            &#125;
                        &#125; while ((e = next) != null);
                        if (loTail != null) &#123;
                            loTail.next = null;
                            //迁移第一条链表
                            newTab[j] = loHead;
                        &#125;
                        if (hiTail != null) &#123;
                            hiTail.next = null;
                            //迁移第二条链表，放在了不同的位置上
                            newTab[j + oldCap] = hiHead;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
        return newTab;
    &#125;
</code></pre>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><blockquote>
<p>你以为还没结束嘛？不不不，HashSet是对HashMap的进一层包装，内部对应的方法都是调用HashMap的，是不是很懒？</p>
</blockquote>
<blockquote>
<p>那我也懒得贴代码了，自己去看吧👀</p>
</blockquote>
<blockquote>
<p>参考自：</p>
<p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet%20and%20HashMap.md">https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet%20and%20HashMap.md</a></p>
<p><a href="https://www.pdai.tech/md/java/collection/java-map-HashMap&amp;HashSet.html#%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9">https://www.pdai.tech/md/java/collection/java-map-HashMap&amp;HashSet.html#数组扩容</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaCollection</category>
      </categories>
      <tags>
        <tag>JavaCollection</tag>
      </tags>
  </entry>
  <entry>
    <title>集合框架之ArrayDeque源码阅读</title>
    <url>/2021/11/21/Collections-ArrayDeque/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Java里有一个叫做Stack的类，却没有叫做Queue的类（它是个接口名字）。<br>当需要使用栈时，Java已不推荐使用Stack，而是推荐使用更高效的ArrayDeque；<br>既然Queue只是一个接口，当需要使用队列时也就首选ArrayDeque了（次选是LinkedList）。</p>
<span id="more"></span>

<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>本文通过讲解<code>ArrayDeque</code>来了解<code>Stack</code> &amp;&amp; <code>Queue</code></p>
<p><code>Deque</code>是”double ended queue”, 表示双向的队列,继承自 Queue接口</p>
<p><img src="/2021/11/21/Collections-ArrayDeque/ArrayDeque_1.png"></p>
<p>除了支持Queue的方法之外，还支持<code>insert</code>, <code>remove</code>和<code>examine</code>操作，由于Deque是双向的，所以可以对队列的头和尾都进行操作，它同时也支持两组格式，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。</p>
<p>Deque的十二个方法如下：</p>
<p><img src="/2021/11/21/Collections-ArrayDeque/ArrayDeque_2.png"></p>
<blockquote>
<p>实际上很好记，前者为抛出异常的实现()，后者为返回值的实现(没有时返回null)，</p>
<p>队列的头和尾都进行操作(增、删、查)，这就是十二个方法</p>
</blockquote>
<p>下表列出了<em>Deque</em>与<em>Queue</em>相对应的接口:</p>
<p><img src="/2021/11/21/Collections-ArrayDeque/ArrayDeque_3.png"></p>
<p>下表列出了<em>Deque</em>与<em>Stack</em>对应的接口：</p>
<p><img src="/2021/11/21/Collections-ArrayDeque/ArrayDeque_4.png"></p>
<blockquote>
<p>当需要使用栈时，Java已不推荐使用<em>Stack</em>这个类，而是推荐使用更高效的<em>ArrayDeque</em>；既然<em>Queue</em>只是一个接口，当需要使用队列时也就首选<em>ArrayDeque</em>了(次选是<em>LinkedList</em>)。</p>
</blockquote>
<h1 id="ArrayDeque的实现"><a href="#ArrayDeque的实现" class="headerlink" title="ArrayDeque的实现"></a>ArrayDeque的实现</h1><p><em>ArrayDeque</em>和<em>LinkedList</em>是<em>Deque</em>的两个通用实现,但官方更推荐使用ArrayDeque来实现栈和队列的功能</p>
<h2 id="ArrayDeque的底层数据结构"><a href="#ArrayDeque的底层数据结构" class="headerlink" title="ArrayDeque的底层数据结构"></a>ArrayDeque的底层数据结构</h2><p>ArrayDeque一看名字就知道是使用数组来实现队列操作，故而该数组必须是循环的，且ArrayDeque是非线程安全的</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code class="java">// 数组本体
transient Object[] elements; 
// 指向队列首端第一个元素
transient int head;
// 指向队列尾端最后一个元素的下一个可插入空位
// 而不是指向队尾元素
transient int tail;

private static final int MIN_INITIAL_CAPACITY = 8;
</code></pre>
<p>这三个方法为ArrayDeque的构造方法</p>
<pre><code class="java">// 构造一个空数组deque，初始容量足以容纳16个元素。
public ArrayDeque() &#123;
    elements = new Object[16];
&#125;

// 构造一个空数组deque，初始容量足以容纳指定数量的元素。
public ArrayDeque(int numElements) &#123;
    allocateElements(numElements);
&#125;
// 构造一个包含指定集合元素的deque，按照它们由集合的迭代器返回的顺序。
public ArrayDeque(Collection&lt;? extends E&gt; c) &#123;
    allocateElements(c.size());
    addAll(c);
&#125;
</code></pre>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>再将方法解析之前，先讲讲扩容</p>
<p>在<strong>构造函数需要构造指定大小的数组</strong>OR上述提到<strong>有关添加的操作</strong>都会涉及到数组的扩容</p>
<p>ArrayDeque的扩容是新直接申请<strong>两倍</strong>(左移一位)的数组空间，然后将原来的数组使用复制<code>System.arraycopy</code>过去</p>
<p><img src="/2021/11/21/Collections-ArrayDeque/ArrayDeque_5.png"></p>
<pre><code class="java">private void doubleCapacity() &#123;
    assert head == tail;
    int p = head;
    int n = elements.length; //旧数组的大小
    int r = n - p; // head右边的元素个数
    int newCapacity = n &lt;&lt; 1; // 新申请数组的大小
    if (newCapacity &lt; 0)
        throw new IllegalStateException(&quot;Sorry, deque too big&quot;);
    Object[] a = new Object[newCapacity];
    System.arraycopy(elements, p, a, 0, r);//复制右半部分，对应上图中绿色部分
    System.arraycopy(elements, 0, a, r, p);//复制左半部分，对应上图中灰色部分
    elements = a;
    head = 0;
    tail = n;
&#125;
</code></pre>
<blockquote>
<p> 结合这两张图就应该很好理解了</p>
</blockquote>
<h2 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h2><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><h3 id="offerFirst"><a href="#offerFirst" class="headerlink" title="offerFirst()"></a>offerFirst()</h3><blockquote>
<p>在此deque前面插入指定的元素。</p>
</blockquote>
<p>我们可以看到，抛出异常的<code>offerFirst</code>是调用的<code>addFirst()</code></p>
<pre><code class="java">public boolean offerFirst(E e) &#123;
    addFirst(e);
    return true;
&#125;
</code></pre>
<h3 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst()"></a>addFirst()</h3><blockquote>
<p>在此deque前面插入指定的元素。</p>
</blockquote>
<p>接着我们来看<code>addFirst()</code></p>
<p><code>addFirst(E e)</code>的作用是在<em>Deque</em>的首端插入元素，也就是在<code>head</code>的前面插入元素，在空间足够且下标没有越界的情况下，只需要将<code>elements[--head] = e</code>即可。</p>
<pre><code class="java">public void addFirst(E e) &#123;
    if (e == null) //不允许放入null
        throw new NullPointerException();
    elements[head = (head - 1) &amp; (elements.length - 1)] = e; //下标是否越界
    if (head == tail) //判断数组是否够用
        doubleCapacity(); //扩容
&#125;
</code></pre>
<blockquote>
<p> 这一段代码写的很有意思</p>
</blockquote>
<p>首先，<code>tail</code>指向的总是下一个可插入空位(n)，<strong>解决了插入空间不够的问题</strong></p>
<p>其次，来看看<code>head = (head - 1) &amp; (elements.length - 1)</code>这一段代码，<code>elements.length</code>总是为2的指数次方(初始容量为2^ 4，扩容每次加倍)，故<code>elements.length - 1</code>的低位<strong>全为1</strong>和<code>head - 1</code>取余数后等于是<strong>取模</strong>了，解决了</p>
<p><code>head - 1</code>为负数的情况(即数组越界的问题)</p>
<h3 id="offerLast"><a href="#offerLast" class="headerlink" title="offerLast()"></a>offerLast()</h3><blockquote>
<p>在此deque的末尾插入指定的元素。</p>
</blockquote>
<p>同样直接调用了<code>addLast()</code></p>
<pre><code class="java">public boolean offerLast(E e) &#123;
    addLast(e);
    return true;
&#125;
</code></pre>
<h3 id="addLast"><a href="#addLast" class="headerlink" title="addLast()"></a>addLast()</h3><blockquote>
<p>在此deque的末尾插入指定的元素。</p>
</blockquote>
<p>上面的addLast提到了，tail总是指向下一个可插入空位，直接<code>elements[tail] = e</code>即可</p>
<pre><code class="java">public void addLast(E e) &#123;
    if (e == null)
        throw new NullPointerException();
    elements[tail] = e;
    if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head) //数组下标越界处理
        doubleCapacity();
&#125;
</code></pre>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="removeFirst"><a href="#removeFirst" class="headerlink" title="removeFirst()"></a>removeFirst()</h3><blockquote>
<p>检索并删除此deque的第一个元素。</p>
</blockquote>
<p>同样是调用了<code>pollFirst()</code>，相比<code>pollFirst()</code>多抛了一个<code>NoSuchElementException()</code>的异常</p>
<pre><code class="java">public E removeFirst() &#123;
    E x = pollFirst();
    if (x == null)
        throw new NoSuchElementException();
    return x;
&#125;
</code></pre>
<h3 id="pollFirst"><a href="#pollFirst" class="headerlink" title="pollFirst()"></a>pollFirst()</h3><blockquote>
<p>检索并删除此deque的第一个元素，如果此deque为空，则返回 <code>null</code> 。</p>
</blockquote>
<p>开头讲到，ArrayList不允许放入null，则当<code>elements[h] = null;</code>的时候，意味着队列为空</p>
<pre><code class="java">public E pollFirst() &#123;
    int h = head;
    @SuppressWarnings(&quot;unchecked&quot;)
    E result = (E) elements[h];
    if (result == null)
        return null;
    elements[h] = null;     // 队列为空
    head = (h + 1) &amp; (elements.length - 1); //下标越界检查
    return result;
&#125;
</code></pre>
<h3 id="removeLast"><a href="#removeLast" class="headerlink" title="removeLast()"></a>removeLast()</h3><blockquote>
<p>检索并删除此deque的最后一个元素。</p>
</blockquote>
<p>同理<code>removeFirst()</code></p>
<pre><code class="java">public E removeLast() &#123;
    E x = pollLast();
    if (x == null)
        throw new NoSuchElementException();
    return x;
&#125;
</code></pre>
<h3 id="pollLast"><a href="#pollLast" class="headerlink" title="pollLast()"></a>pollLast()</h3><blockquote>
<p>检索并删除此deque的最后一个元素，如果此deque为空，则返回 <code>null</code> 。</p>
</blockquote>
<p>移除的是<code>tail</code>位置前一个元素</p>
<pre><code class="java">public E pollLast() &#123;
    int t = (tail - 1) &amp; (elements.length - 1);
    @SuppressWarnings(&quot;unchecked&quot;)
    E result = (E) elements[t];
    if (result == null)
        return null;
    elements[t] = null;
    tail = t;
    return result;
&#125;
</code></pre>
<h2 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h2><p>这个与上面删除的区别是</p>
<ul>
<li>删除 = 删除元素 + 检索(返回删除的元素）</li>
<li>检索 =  返回该元素</li>
</ul>
<p>就是<strong>get</strong>的意思？</p>
<h3 id="getFirst"><a href="#getFirst" class="headerlink" title="getFirst()"></a>getFirst()</h3><blockquote>
<p>检索，但不删除，这个deque的第一个元素。</p>
</blockquote>
<pre><code class="java">public E getFirst() &#123;
    @SuppressWarnings(&quot;unchecked&quot;)
    E result = (E) elements[head];
    if (result == null)
        throw new NoSuchElementException();
    return result;
&#125;
</code></pre>
<h3 id="peekFirst"><a href="#peekFirst" class="headerlink" title="peekFirst()"></a>peekFirst()</h3><blockquote>
<p>检索但不删除此deque的第一个元素，如果此deque为空，则返回 <code>null</code></p>
</blockquote>
<pre><code class="java">@SuppressWarnings(&quot;unchecked&quot;)
public E peekFirst() &#123;
    // elements[head] is null if deque empty
    return (E) elements[head];
&#125;
</code></pre>
<h3 id="getLast"><a href="#getLast" class="headerlink" title="getLast()"></a>getLast()</h3><blockquote>
<p>检索，但不删除，这个deque的最后一个元素。</p>
</blockquote>
<pre><code class="java">public E getLast() &#123;
    @SuppressWarnings(&quot;unchecked&quot;)
    E result = (E) elements[(tail - 1) &amp; (elements.length - 1)];
    if (result == null)
        throw new NoSuchElementException();
    return result;
&#125;
</code></pre>
<h3 id="peekLast"><a href="#peekLast" class="headerlink" title="peekLast()"></a>peekLast()</h3><blockquote>
<p>检索但不删除此deque的最后一个元素，或返回 <code>null</code>如果此deque为空）。</p>
</blockquote>
<pre><code class="java">@SuppressWarnings(&quot;unchecked&quot;)
public E peekLast() &#123;
    return (E) elements[(tail - 1) &amp; (elements.length - 1)];
&#125;
</code></pre>
<blockquote>
<p>注意⚠️：</p>
<p>检索的<code>getFirst()</code>和<code>getLast()</code>会对null抛出异常</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaCollection</category>
      </categories>
      <tags>
        <tag>JavaCollection</tag>
      </tags>
  </entry>
  <entry>
    <title>集合框架之LinkedList源码阅读</title>
    <url>/2021/11/20/Collections-LinkedList/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><em>LinkedList</em>同时实现了<strong><em>List</em>接口</strong>和<strong><em>Deque</em>接口</strong>，也就是说它既可以看作一个顺序容器，又可以看作一个队列(<em>Queue</em>)，同时又可以看作一个栈(<em>Stack</em>)</p>
<span id="more"></span>

<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p><em>LinkedList</em>同时实现了<strong><em>List</em>接口</strong>和<strong><em>Deque</em>接口</strong>，也就是说它既可以看作一个顺序容器，又可以看作一个队列(<em>Queue</em>)，同时又可以看作一个栈(<em>Stack</em>)。<br>当你需要使用栈或者队列时，可以考虑使用<em>LinkedList</em>，关于栈或队列，现在的首选是<em>ArrayDeque</em>，它有着比<em>LinkedList</em>(当作栈或队列使用时)有着更好的性能。</p>
<p>截取了一张图来说明一下<code>LinkedList</code>的实现关系</p>
<p><img src="/2021/11/20/Collections-LinkedList/LinkedList_1.png"></p>
<h1 id="LinkedList的实现"><a href="#LinkedList的实现" class="headerlink" title="LinkedList的实现"></a>LinkedList的实现</h1><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><p>LinkedList的底层是通过<strong>双向链表</strong>实现的</p>
<p>通过<code>first</code>和<code>last</code>分别引用指向链表的<code>第一个</code>和最后一个元素</p>
<p>当链表为空时，<code>first</code>和<code>last</code>分别引用指向<code>null</code></p>
<pre><code class="java">transient int size = 0;

    transient Node&lt;E&gt; first;

    transient Node&lt;E&gt; last;
</code></pre>
<p>其中，node是其中的一个内部私有类</p>
<pre><code class="java">private static class Node&lt;E&gt; &#123;
        E item;
        Node&lt;E&gt; next;
        Node&lt;E&gt; prev;

        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;
            this.item = element;
            this.next = next;
            this.prev = prev;
        &#125;
    &#125;
</code></pre>
<p><em>LinkedList</em>的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。</p>
<p>为追求效率<em>LinkedList</em>没有实现同步（synchronized），如果需要多个线程并发访问，可以先采用<code>Collections.synchronizedList()</code>方法对其进行包装。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code class="java">  
    public LinkedList() &#123;
    &#125;

    public LinkedList(Collection&lt;? extends E&gt; c) &#123;
        this();
        addAll(c);
    &#125;
</code></pre>
<h2 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h2><h3 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h3><p>这一个是默认插在链表的最后</p>
<pre><code class="java">  public boolean add(E e) &#123;
        linkLast(e);
        return true;
    &#125;
</code></pre>
<pre><code class="java">/**
 * Links e as last element.
 */
void linkLast(E e) &#123;
    final Node&lt;E&gt; l = last;
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);
    last = newNode;
    if (l == null)
        first = newNode;
    else
        l.next = newNode;
    size++;
    modCount++;
&#125;
</code></pre>
<p>这一个是根据索引插入</p>
<pre><code class="java">public void add(int index, E element) &#123;
      //这一步是检查插入索引位置是否符合要求
      //判断index是否在[0，size]区间内
    checkPositionIndex(index);

      //当插入索引位置在最后时，直接插入最后
    if (index == size)
        linkLast(element);
    else
          //添加的元素索引位置不在最后时
        linkBefore(element, node(index));
&#125;
</code></pre>
<p>关于<code>node(int index)</code></p>
<p>返回指定索引下的node，该链表为双向的，根据<code>index &lt; (size &gt;&gt; 1)</code>来判断index靠近前端还是后端，可以看出，LinkedList查找的效率并没有ArrayList高（LinkedList是线性的时间长度）</p>
<pre><code class="java"> Node&lt;E&gt; node(int index) &#123;
        // assert isElementIndex(index);

        if (index &lt; (size &gt;&gt; 1)) &#123;
            Node&lt;E&gt; x = first;
            for (int i = 0; i &lt; index; i++)
                x = x.next;
            return x;
        &#125; else &#123;
            Node&lt;E&gt; x = last;
            for (int i = size - 1; i &gt; index; i--)
                x = x.prev;
            return x;
        &#125;
    &#125;
</code></pre>
<p>现在我们来看看 <code>linkBefore(element, node(index))</code></p>
<pre><code class="java">/**
 * Inserts element e before non-null Node succ.
 */
void linkBefore(E e, Node&lt;E&gt; succ) &#123;
    // assert succ != null;
      // 
    final Node&lt;E&gt; pred = succ.prev;
      //
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);
    succ.prev = newNode;
    if (pred == null)
        first = newNode;
    else
        pred.next = newNode;
    size++;
    modCount++;
&#125;
</code></pre>
<h3 id="addAll"><a href="#addAll" class="headerlink" title="addAll()"></a>addAll()</h3><p>不加索引位置时，默认添加至最后，调用<code>addAll(int index, Collection&lt;? extends E&gt; c)</code>方法</p>
<pre><code class="java"> public boolean addAll(Collection&lt;? extends E&gt; c) &#123;
        return addAll(size, c);
    &#125;
</code></pre>
<p>按照索引位置插入</p>
<pre><code class="java">   public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;
        checkPositionIndex(index);

        Object[] a = c.toArray();
        int numNew = a.length;
        if (numNew == 0)
            return false;

        Node&lt;E&gt; pred, succ;
        if (index == size) &#123;
            succ = null;
            pred = last;
        &#125; else &#123;
            succ = node(index);
            pred = succ.prev;
        &#125;

        for (Object o : a) &#123;
            @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;
            Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);
            if (pred == null)
                first = newNode;
            else
                pred.next = newNode;
            pred = newNode;
        &#125;

        if (succ == null) &#123;
            last = pred;
        &#125; else &#123;
            pred.next = succ;
            succ.prev = pred;
        &#125;

        size += numNew;
        modCount++;
        return true;
    &#125;
</code></pre>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p>删除出现的第一个元素，如果没有，则返回null，由于LinkedList也可以存null，因此，也可以删除第一次出现的null元素</p>
<pre><code class="java">public boolean remove(Object o) &#123;
        if (o == null) &#123;
            for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;
                if (x.item == null) &#123;
                    unlink(x);
                    return true;
                &#125;
            &#125;
        &#125; else &#123;
            for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;
                if (o.equals(x.item)) &#123;
                    unlink(x);
                    return true;
                &#125;
            &#125;
        &#125;
        return false;
    &#125;
</code></pre>
<pre><code class="java">    /**
     * Unlinks non-null node x.
     */
    E unlink(Node&lt;E&gt; x) &#123;
        // assert x != null;
        final E element = x.item;
        final Node&lt;E&gt; next = x.next;
        final Node&lt;E&gt; prev = x.prev;

          //第一个元素时
        if (prev == null) &#123;
            first = next;
        &#125; else &#123;
            prev.next = next;
            x.prev = null;
        &#125;

          //最后一个元素时
        if (next == null) &#123;
            last = prev;
        &#125; else &#123;
            next.prev = prev;
            x.next = null;
        &#125;

          // null
        x.item = null;
        size--;
        modCount++;
        return element;
    &#125;
</code></pre>
<p>删除指定索引的node</p>
<pre><code class="java">public E remove(int index) &#123;
        checkElementIndex(index);
        return unlink(node(index));
    &#125;
</code></pre>
<blockquote>
<p>removeFirest(), removeLast()同比，就不放出来了</p>
</blockquote>
<h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><p>清空引用关系，方便gc快速回收</p>
<pre><code class="java">public void clear() &#123;
        // Clearing all of the links between nodes is &quot;unnecessary&quot;, but:
        // - helps a generational GC if the discarded nodes inhabit
        //   more than one generation
        // - is sure to free memory even if there is a reachable Iterator
        for (Node&lt;E&gt; x = first; x != null; ) &#123;
            Node&lt;E&gt; next = x.next;
            x.item = null;
            x.next = null;
            x.prev = null;
            x = next;
        &#125;
        first = last = null;
        size = 0;
        modCount++;
    &#125;
</code></pre>
<h2 id="关于modCount"><a href="#关于modCount" class="headerlink" title="关于modCount"></a>关于modCount</h2><p>LinkedList虽然是线程不安全的，但是也有快速失败的机制，通过记录<code>modCount</code>参数来实现。(同比参考ArrayList)</p>
<blockquote>
<p>参考</p>
<ul>
<li><p>Java LinkedList源码剖析 结合源码对LinkedList进行讲解 <a href="http://www.cnblogs.com/CarpenterLee/p/5457150.html">http://www.cnblogs.com/CarpenterLee/p/5457150.html</a></p>
</li>
<li><p>Java™ Platform, Standard Edition 8 API Specification</p>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>JavaCollection</category>
      </categories>
      <tags>
        <tag>JavaCollection</tag>
      </tags>
  </entry>
  <entry>
    <title>集合框架之ArrayList源码阅读</title>
    <url>/2021/11/18/Collections-ArrayList/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>ArrayList实现了List接口，是顺序容器，即元素存放的数据与放进去的顺序相同。</p>
<span id="more"></span>

<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>ArrayList实现了List接口，是顺序容器，即元素存放的数据与放进去的顺序相同，<br>允许放入null元素，底层通过数组实现。除该类未实现同步外，其余跟Vector大致相同。</p>
<p>每个ArrayList都有一个容量（capacity），表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。</p>
<p>当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，<br>所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。</p>
<h1 id="ArrayList的实现"><a href="#ArrayList的实现" class="headerlink" title="ArrayList的实现"></a>ArrayList的实现</h1><h2 id="ArrayList的底层数据结构"><a href="#ArrayList的底层数据结构" class="headerlink" title="ArrayList的底层数据结构"></a>ArrayList的底层数据结构</h2><pre><code class="java">        /**
     * The array buffer into which the elements of the ArrayList are stored.
     * The capacity of the ArrayList is the length of this array buffer. Any
     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA
     * will be expanded to DEFAULT_CAPACITY when the first element is added.
     */
    transient Object[] elementData; // non-private to simplify nested class access
</code></pre>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code class="java">    /**
     * Constructs an empty list with the specified initial capacity.
     *
     * @param  initialCapacity  the initial capacity of the list
     * @throws IllegalArgumentException if the specified initial capacity
     *         is negative
     */
    public ArrayList(int initialCapacity) &#123;
        if (initialCapacity &gt; 0) &#123;
            this.elementData = new Object[initialCapacity];
        &#125; else if (initialCapacity == 0) &#123;
            //在jdk7时，element初始化为长度为10的数组
            //在jdk8后，elementData初始化为&#123;&#125;，并没有创建长度，在第一次调用add()后才创建长度
            //其中，private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;
            this.elementData = EMPTY_ELEMENTDATA;
        &#125; else &#123;
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        &#125;
    &#125;

    /**
     * Constructs an empty list with an initial capacity of ten.
     */
    public ArrayList() &#123;
        //其中 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    &#125;

    /**
     * Constructs a list containing the elements of the specified
     * collection, in the order they are returned by the collection&#39;s
     * iterator.
     *
     * @param c the collection whose elements are to be placed into this list
     * @throws NullPointerException if the specified collection is null
     */
    public ArrayList(Collection&lt;? extends E&gt; c) &#123;
        Object[] a = c.toArray();
        if ((size = a.length) != 0) &#123;
            if (c.getClass() == ArrayList.class) &#123;
                elementData = a;
            &#125; else &#123;
                elementData = Arrays.copyOf(a, size, Object[].class);
            &#125;
        &#125; else &#123;
            // replace with empty array.
            elementData = EMPTY_ELEMENTDATA;
        &#125;
    &#125;
</code></pre>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><h3 id="ensureCapacity"><a href="#ensureCapacity" class="headerlink" title="ensureCapacity()"></a>ensureCapacity()</h3><blockquote>
<p>扩容操作最终是通过<code>grow()</code>方法完成的</p>
</blockquote>
<p>向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数。能减少<code>add()</code>所耗费的时间</p>
<p><img src="/2021/11/18/Collections-ArrayList/ArrayList_1.png"></p>
<p><code>ensureCapacity</code> 方法内大致的执行顺序是：</p>
<ul>
<li><code>ensureCapacity()</code> —&gt;<code>ensureCapacityInternal()</code>—&gt;<code>ensureExplicitCapacity()</code>—&gt;<code>grow()</code>—&gt;<code>Arrays.copyOf()</code></li>
</ul>
<pre><code class="java">    /**
     * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if
     * necessary, to ensure that it can hold at least the number of elements
     * specified by the minimum capacity argument.
     *
     * @param   minCapacity   the desired minimum capacity
     */
        //如果需要，增加此 ArrayList实例的容量，以确保它可以至少保存最小容量参数指定的元素数。
    public void ensureCapacity(int minCapacity) &#123;
        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
            // any size if not default element table
            ? 0
            // larger than default for default empty table. It&#39;s already
            // supposed to be at default size.
            : DEFAULT_CAPACITY;

        if (minCapacity &gt; minExpand) &#123;
            ensureExplicitCapacity(minCapacity);
        &#125;
    &#125;
    //当minCapacity小于10(DEFAULT_CAPACITY)时，返回10(DEFAULT_CAPACITY)
    private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        &#125;
        return minCapacity;
    &#125;

    private void ensureCapacityInternal(int minCapacity) &#123;
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    &#125;
    // 判断是否申请额外空间：如果申请容量比当前数组元素的实际长度大 则进入方法 grow
    private void ensureExplicitCapacity(int minCapacity) &#123;
        modCount++;

        // overflow-conscious code
        if (minCapacity - elementData.length &gt; 0)
            grow(minCapacity);
    &#125;

    /**
     * The maximum size of array to allocate.
     * Some VMs reserve some header words in an array.
     * Attempts to allocate larger arrays may result in
     * OutOfMemoryError: Requested array size exceeds VM limit
     */
    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

    /**
     * Increases the capacity to ensure that it can hold at least the
     * number of elements specified by the minimum capacity argument.
     *
     * @param minCapacity the desired minimum capacity
     */
    private void grow(int minCapacity) &#123;
        // overflow-conscious code
          // 原数组长度
        int oldCapacity = elementData.length;
          // 新数组长度约为原数组长度的1.5倍
        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
        if (newCapacity - minCapacity &lt; 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    &#125;
        //这一步说明了数组的最大长度可以为Integer.MAX_VALUE
        //而不是之前定义的Integer.MAX_VALUE - 8;
    private static int hugeCapacity(int minCapacity) &#123;
        if (minCapacity &lt; 0) // overflow
            throw new OutOfMemoryError();
        return (minCapacity &gt; MAX_ARRAY_SIZE) ?
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
    &#125;
</code></pre>
<h2 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h2><h3 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h3><p>其中，<code>add(int index, E element)</code>具有线性的时间复杂度</p>
<pre><code class="java">    /**
     * Appends the specified element to the end of this list.
     *
     * @param e element to be appended to this list
     * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;)
     */
    public boolean add(E e) &#123;
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    &#125;

    /**
     * Inserts the specified element at the specified position in this
     * list. Shifts the element currently at that position (if any) and
     * any subsequent elements to the right (adds one to their indices).
     *
     * @param index index at which the specified element is to be inserted
     * @param element element to be inserted
     * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;
     */
    public void add(int index, E element) &#123;
          // 检查index是否符合要求
          // 否则抛出IndexOutOfBoundsException异常
        rangeCheckForAdd(index);

        ensureCapacityInternal(size + 1);  // Increments modCount!!co
          // 拷贝操作
        System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
        elementData[index] = element;
        size++;
    &#125;
</code></pre>
<h3 id="addAll"><a href="#addAll" class="headerlink" title="addAll"></a>addAll</h3><p>根据位置不同也有两个版本， <code>addAll()</code>的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。</p>
<pre><code class="java">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;
        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacityInternal(size + numNew);  // Increments modCount
        System.arraycopy(a, 0, elementData, size, numNew);
        size += numNew;
        return numNew != 0;
    &#125;
</code></pre>
<pre><code class="java">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;
              //检查index是否合格，否则抛出IndexOutOfBoundsException异常
        rangeCheckForAdd(index);

        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacityInternal(size + numNew);  // Increments modCount

        int numMoved = size - index;
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index, elementData, index + numNew,
                             numMoved);

        System.arraycopy(a, 0, elementData, index, numNew);
        size += numNew;
        return numNew != 0;
    &#125;
</code></pre>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p><code>remove()</code>方法也有两个版本</p>
<p>一个是<code>remove(int index)</code>删除指定位置的元素</p>
<p>另一个是<code>remove(Object o)</code>删除第一个满足<code>o.equals(elementData[index])</code>的元素.</p>
<p>删除操作是<code>add()</code>操作的逆过程，需要将删除点之后的元素向前移动一个位置。</p>
<blockquote>
<p>最后一个位置不手动赋<code>null</code>值，除非对应的位置被其他元素覆盖，否则原来的对象就一直不会被回收。</p>
</blockquote>
<pre><code class="java">    /**
     * Removes the element at the specified position in this list.
     * Shifts any subsequent elements to the left (subtracts one from their
     * indices).
     *
     * @param index the index of the element to be removed
     * @return the element that was removed from the list
     * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;
     */
    public E remove(int index) &#123;
        rangeCheck(index);

        modCount++;
        E oldValue = elementData(index);

        int numMoved = size - index - 1;
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work

        return oldValue;
    &#125;
</code></pre>
<pre><code class="java">    /**
     * Removes the first occurrence of the specified element from this list,
     * if it is present.  If the list does not contain the element, it is
     * unchanged.  More formally, removes the element with the lowest index
     * &lt;tt&gt;i&lt;/tt&gt; such that
     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;
     * (if such an element exists).  Returns &lt;tt&gt;true&lt;/tt&gt; if this list
     * contained the specified element (or equivalently, if this list
     * changed as a result of the call).
     *
     * @param o element to be removed from this list, if present
     * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element
     */
    public boolean remove(Object o) &#123;
        if (o == null) &#123;
            for (int index = 0; index &lt; size; index++)
                if (elementData[index] == null) &#123;
                    fastRemove(index);
                    return true;
                &#125;
        &#125; else &#123;
            for (int index = 0; index &lt; size; index++)
                if (o.equals(elementData[index])) &#123;
                    fastRemove(index);
                    return true;
                &#125;
        &#125;
        return false;
    &#125;
</code></pre>
<h3 id="trimToSize"><a href="#trimToSize" class="headerlink" title="trimToSize()"></a>trimToSize()</h3><p>把扩容后未使用的空间去掉，保留有元素的部分</p>
<pre><code class="java">    /**
     * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the
     * list&#39;s current size.  An application can use this operation to minimize
     * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance.
     */
    public void trimToSize() &#123;
        modCount++;
        if (size &lt; elementData.length) &#123;
              //复制了elementData中的size个有效元素，再重新给elementData
            elementData = (size == 0)
              ? EMPTY_ELEMENTDATA
              : Arrays.copyOf(elementData, size);
        &#125;
    &#125;
</code></pre>
<h2 id="关于modCount"><a href="#关于modCount" class="headerlink" title="关于modCount"></a>关于modCount</h2><p>ArrayList虽然是线程不安全的，但是也有快速失败的机制，通过记录<code>modCount</code>参数来实现。</p>
<p>可以看到源码中有很多<code>modCount++;</code>的操作,每一次ArrayList结构发生改变的时候(上述提到的所有方法)，都会记录一次，在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p>
<p>用此变量来检验在迭代过程中List对象是否被修改了，如果被修改了则抛出来java.util.ConcurrentModificationException异常</p>
<h2 id="关于-Arrays-copyOf-和-System-arraycopy"><a href="#关于-Arrays-copyOf-和-System-arraycopy" class="headerlink" title="关于 Arrays.copyOf 和 System.arraycopy"></a>关于 Arrays.copyOf 和 System.arraycopy</h2><h3 id="Arrays-copyOf"><a href="#Arrays-copyOf" class="headerlink" title="Arrays.copyOf"></a>Arrays.copyOf</h3><pre><code class="java">    public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123;
        @SuppressWarnings(&quot;unchecked&quot;)
        T[] copy = ((Object)newType == (Object)Object[].class)
            ? (T[]) new Object[newLength]
            : (T[]) Array.newInstance(newType.getComponentType(), newLength);
        System.arraycopy(original, 0, copy, 0,
                         Math.min(original.length, newLength));
        return copy;
    &#125;
</code></pre>
<h3 id="System-arraycopy"><a href="#System-arraycopy" class="headerlink" title="System.arraycopy"></a>System.arraycopy</h3><pre><code class="java">public static native void arraycopy(Object src,  int  srcPos,
                                        Object dest, int destPos,
                                        int length);
</code></pre>
<p>可以看到，Arrays.copyOf内调用了System.arraycopy。</p>
<p>简单的说，Array.copyOf()可以看作是受限的System.arraycopy(),它主要是用来将原数组全部拷贝到一个新长度的数组，适用于数组扩容。</p>
]]></content>
      <categories>
        <category>JavaCollection</category>
      </categories>
      <tags>
        <tag>JavaCollection</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch踩坑记录</title>
    <url>/2021/11/08/ElasticSearch_error/</url>
    <content><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>入门小白一定要给es开大一点的jvm堆空间！别不点进来就走！</p>
<span id="more"></span>

<h1 id="ElasticSearch踩坑记录"><a href="#ElasticSearch踩坑记录" class="headerlink" title="ElasticSearch踩坑记录"></a>ElasticSearch踩坑记录</h1><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>环境：docker安装了es和kibana，其中服务器为1核2g，考虑到es会占用较大内存，在容器启动的时候就限制了堆大小<code>ES_JAVA_OPTS=&quot;-Xms64m -Xmx128m</code></p>
<p>在学习es分词器的时候，在给es安装了ik分词器插件后，restart后kibana连接不上es，查看es的日志显示:</p>
<pre><code>&#123;&quot;type&quot;: &quot;server&quot;, &quot;timestamp&quot;: &quot;2021-11-08T13:16:26,709Z&quot;, &quot;level&quot;: &quot;INFO&quot;, &quot;component&quot;: &quot;o.e.c.r.a.AllocationService&quot;, &quot;cluster.name&quot;: &quot;elasticsearch&quot;, &quot;node.name&quot;: &quot;aee86155b1ca&quot;, &quot;message&quot;: &quot;Cluster health status changed from [RED] to [YELLOW] (reason: [shards started [[.kibana_1][0]]]).&quot;, &quot;cluster.uuid&quot;: &quot;Q5-PS477TBSHlcrsvR7cEg&quot;, &quot;node.id&quot;: &quot;O_-bMvZZQAG6XjGQvX_UFA&quot;  &#125; 

&#123;&quot;type&quot;: &quot;server&quot;, &quot;timestamp&quot;: &quot;2021-11-08T13:16:26,863Z&quot;, &quot;level&quot;: &quot;INFO&quot;, &quot;component&quot;: &quot;o.e.m.j.JvmGcMonitorService&quot;, &quot;cluster.name&quot;: &quot;elasticsearch&quot;, &quot;node.name&quot;: &quot;aee86155b1ca&quot;, &quot;message&quot;: &quot;[gc][6] overhead, spent [355ms] collecting in the last [1s]&quot;, &quot;cluster.uuid&quot;: &quot;Q5-PS477TBSHlcrsvR7cEg&quot;, &quot;node.id&quot;: &quot;O_-bMvZZQAG6XjGQvX_UFA&quot;  &#125;

&#123;&quot;type&quot;: &quot;server&quot;, &quot;timestamp&quot;: &quot;2021-11-08T13:16:51,973Z&quot;, &quot;level&quot;: &quot;INFO&quot;, &quot;component&quot;: &quot;o.e.m.j.JvmGcMonitorService&quot;, &quot;cluster.name&quot;: &quot;elasticsearch&quot;, &quot;node.name&quot;: &quot;aee86155b1ca&quot;, &quot;message&quot;: &quot;[gc][31] overhead, spent [310ms] collecting in the last [1s]&quot;, &quot;cluster.uuid&quot;: &quot;Q5-PS477TBSHlcrsvR7cEg&quot;, &quot;node.id&quot;: &quot;O_-bMvZZQAG6XjGQvX_UFA&quot;  &#125;
</code></pre>
<p>一看，好像没什么问题，在postman向es发送请求也能return，查看节点健康状况也没问题</p>
<p>接着想到了kibana的问题，尝试查看kibana的日志，一看，好家伙：</p>
<pre><code>[parent] Data too large, data for [&lt;http_request&gt;] would be [125973240/120.1mb], which is larger than the limit of [123273216/117.5mb],
</code></pre>
<blockquote>
<p>截取了其中一部分日志</p>
</blockquote>
<p>就想到可能分配给es的堆内存不够，上网查阅了一下资料，大概有两种方式：</p>
<ul>
<li><p>修改<code>jvm.options</code>的堆内存配置</p>
<pre><code class="yaml">-Xms64m
-Xmx256m
</code></pre>
<p>这里根据自己服务器的配置修改使用</p>
</li>
<li><p>修改<code>elasticsearch.yml</code>关于内存回收的配置</p>
<pre><code class="yaml"># 有了这个设置，最久未使用（LRU）的 fielddata 会被回收为新数据腾出空间
# 控制fielddata允许内存大小，达到HEAP 20% 自动清理旧cache
indices.fielddata.cache.size: 20%
indices.breaker.total.use_real_memory: false
# fielddata 断路器默认设置堆的 60% 作为 fielddata 大小的上限。
indices.breaker.fielddata.limit: 40%
# request 断路器估算需要完成其他请求部分的结构大小，例如创建一个聚合桶，默认限制是堆内存的 40%。
indices.breaker.request.limit: 40%
# total 揉合 request 和 fielddata 断路器保证两者组合起来不会使用超过堆内存的 70%(默认值)。
indices.breaker.total.limit: 95%
</code></pre>
<p>这一部分是直接抄作业的，详细的内容还是得以后再学</p>
</li>
</ul>
<p>修改后启动查看日志，欧真不错！</p>
<p><img src="/2021/11/08/ElasticSearch_error/11.8_1.png"></p>
<blockquote>
<p>攒钱买服务器去了，呜呜呜～</p>
</blockquote>
<p><img src="/2021/11/08/ElasticSearch_error/11.8_2.png"></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch初探</title>
    <url>/2021/11/06/ElasticSearch/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ElasticSearch作为ELK搜索引擎三剑客里一员，作为分布式搜索引擎和数据分析引擎，提供了全文检索、结构化搜索以及聚合等功能，应用于大数据和作为搜索引擎等方向</p>
<span id="more"></span>

<h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><h2 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h2><h3 id="初步"><a href="#初步" class="headerlink" title="初步"></a>初步</h3><ul>
<li><p>_cat</p>
<ul>
<li><p> <strong>GET + /_cat/nodes</strong> ：查看所有节点</p>
</li>
<li><p> <strong>GET + /_cat/health</strong> ：检查es健康情况</p>
</li>
<li><p> <strong>GET + /_cat/master</strong> ：查看主节点</p>
</li>
<li><p> <strong>GET + /_cat/indices</strong> ： 查看所有索引</p>
</li>
</ul>
</li>
<li><p> 索引一个文档（保存），格式：</p>
</li>
<li><p><strong>PUT +  customer/extend/1 + json数据</strong>： PUT请求，保存在<strong>customer索引</strong>下的<strong>extend类型</strong>下的<strong>id为1</strong>的<strong>数据</strong>(json内容)</p>
<ul>
<li>其中，POST请求可带可不带id，不带的话会自动生成一个新的id（并新增版本号，<code>_seq_no</code>，乐观锁），而PUT请求必须指定id</li>
</ul>
</li>
</ul>
<p><img src="/2021/11/06/ElasticSearch/11.6_1.png"></p>
<ul>
<li><p>查询文档</p>
<ul>
<li><strong>GET + customer/extend/1</strong> 格式同上</li>
</ul>
</li>
<li><p>更新文档</p>
<ul>
<li><p><strong>POST + /customer/extend/1/_update</strong></p>
<ul>
<li><p>只能用<strong>post</strong>请求,注意json内容</p>
</li>
<li><p>当es检索到更新内容不变时，result显示noop（表示没有变更），此时<code>_version</code>和<code>_seq_no</code>的数值均未变</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/11/06/ElasticSearch/11.6_2.png"></p>
<ul>
<li><p>删除文档&amp;&amp;索引</p>
<ul>
<li><strong>DELETE + customer/extend/1</strong></li>
<li><strong>DELETE + customer</strong><ul>
<li>es未提供删除某种特定类型的操作</li>
</ul>
</li>
</ul>
</li>
<li><p>bulk批量API</p>
<ul>
<li><p>格式：</p>
<pre><code class="json">&#123;action:&#123;metadata&#125;&#125;
&#123;requstbody&#125;
</code></pre>
<ul>
<li><code>action</code>指行为：包含create、update、index、delete<ul>
<li>如果数据存在(相同)，create会执行失败，index可以成功执行</li>
</ul>
</li>
<li><code>metadata</code>指具体索引信息，需要指明<code>_index</code>、<code>_type</code>、-<code>_id</code>(用来替代发送request请求中url的信息)</li>
<li><code>Requestbody</code>则是对应的json数据（批量删除时不需要请求体）</li>
</ul>
</li>
<li><p>可以在kibana提供的控制台中操控</p>
</li>
<li><blockquote>
<p>思考：为什么批量处理的数据格式不为<code>[&#123;&quot;action&quot;:&#123;&#125;,&quot;data&quot;:&#123;&#125;&#125;]</code>呢，这样可读性更好？</p>
<ul>
<li>刚开始我也很疑惑，查阅博客后，说是考虑到java虚拟机的性能，使用<code>es</code>等已经是比较耗费内存的了，还得解析json数组后在进行操作，前者相对于后者少了<strong>解析</strong>这一步操作</li>
</ul>
</blockquote>
<blockquote>
<p>一次bulk的数据不应该太多</p>
<ul>
<li>容易导致超时，默认超时时间10s</li>
<li>数据太多性能会下降</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>ES在7.0版本后逐渐移除了类型/type这一概念</p>
<p>![截屏2021-11-08 下午3.56.10](/Users/kokorozashiguohuang/Library/Application Support/typora-user-images/截屏2021-11-08 下午3.56.10.png)</p>
<p>在7.0版本使用type类型进行操作时，会有warn提示</p>
<p>但8.0版本则是强制报错</p>
<p>查阅了es的官方文档和一些博客后，总结了一下：</p>
<p>es基于lucene开发，而在lucene中，没有type的概念的。</p>
<p>表面上看，es的<strong>index(索引)<strong>对比的是</strong>数据库</strong>，<strong>type(类型)<strong>对应的是</strong>表</strong>，**field(字段)**类比的是一行数据</p>
<p>可是在内部里，一个index(索引)不同type(类型)下同名field(字段)在储存在lucene内部同一个field(字段)中，es之前版本通过维护_type字段来专门区分不同的type。</p>
<p>换句话说，就是数据库允许<strong>同一个库</strong>下<strong>不同表</strong>有<strong>同名的列</strong>，而es不允许。</p>
<p>这会带来数据检索的一些不便以及由于数据稀疏造成影响es压缩数据性能等不便</p>
<h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2021/10/21/Operating_system/</url>
    <content><![CDATA[<p>学习操作系统时候的一些<strong>输出</strong>，目的是为了加强记忆以及后续时间能快速复习这一部分的知识</p>
<span id="more"></span>

<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p>分段会产生内存碎片，以及内存交换的效率低的问题</p>
<h4 id="什么是内存交换呢？"><a href="#什么是内存交换呢？" class="headerlink" title="什么是内存交换呢？"></a>什么是内存交换呢？</h4><ul>
<li><p>分段式内存管理会产生一些内存碎片</p>
<ul>
<li>外部碎片-&gt;产生多个不连续的小内存</li>
<li>内部碎片-&gt;程序<strong>不常用</strong>的内存也被装在到物理内存上</li>
</ul>
</li>
<li><p>为了利用好这一部分的内存碎片（外部），可以把通过把程序<strong>从内存读入硬盘</strong>再从<strong>硬盘重新读到内存</strong>的方式，这一部分在硬盘上的空间就叫做内存交换空间</p>
</li>
</ul>
<h4 id="为什么内存分段的内存交换率低呢？"><a href="#为什么内存分段的内存交换率低呢？" class="headerlink" title="为什么内存分段的内存交换率低呢？"></a>为什么内存分段的内存交换率低呢？</h4><ul>
<li>频繁的交换可能会产生性能瓶颈</li>
<li>交换的程序占用内存比较大的时候，机器可能因为性能原因造成卡顿</li>
</ul>
<h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p>为了解决内存分段的问题</p>
<p>把内存空间切成固定尺寸（4kb）的连续空间（页）</p>
<h4 id="怎么解决内存碎片和交换率低的问题呢？"><a href="#怎么解决内存碎片和交换率低的问题呢？" class="headerlink" title="怎么解决内存碎片和交换率低的问题呢？"></a>怎么解决内存碎片和交换率低的问题呢？</h4><ul>
<li>内存碎片：内存分页的机制决定了不会产生无法利用的小内存</li>
<li>交换率低<ul>
<li>当程序加载时，物理内存只加载虚拟内存页里面<strong>需要用到</strong>的指令和数据（并不一次加载一个完整的程序）</li>
<li>内存空间不够时，会将「不常用」的内存页给写入硬盘中（<strong>释放</strong>），需要用时再加载进来</li>
</ul>
</li>
</ul>
<h3 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h3><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><hr>
<h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><h4 id="先来先服务调度算法（First-Come-First-Severd-FCFS）"><a href="#先来先服务调度算法（First-Come-First-Severd-FCFS）" class="headerlink" title="先来先服务调度算法（First Come First Severd, FCFS）"></a>先来先服务调度算法（<strong>First Come First Severd, FCFS</strong>）</h4><h4 id="最短作业优先调度算法（Shortest-Job-First-SJF）"><a href="#最短作业优先调度算法（Shortest-Job-First-SJF）" class="headerlink" title="最短作业优先调度算法（Shortest Job First, SJF）"></a>最短作业优先调度算法（<strong>Shortest Job First, SJF</strong>）</h4><h4 id="高响应比优先调度算法（Highest-Response-Ratio-Next-HRRN）"><a href="#高响应比优先调度算法（Highest-Response-Ratio-Next-HRRN）" class="headerlink" title="高响应比优先调度算法（Highest Response Ratio Next, HRRN）"></a>高响应比优先调度算法（<strong>Highest Response Ratio Next, HRRN</strong>）</h4><p><img src="/2021/10/21/Operating_system/Process_scheduling_1.png"></p>
<h4 id="时间片轮转调度算法（Round-Robin-RR）"><a href="#时间片轮转调度算法（Round-Robin-RR）" class="headerlink" title="时间片轮转调度算法（Round Robin, RR）"></a>时间片轮转调度算法（<strong>Round Robin, RR</strong>）</h4><ul>
<li>每个进程分配一个时间片，允许进程在该时间段中运行<ul>
<li>时间片用完，进程还在运行则切换另一个进程</li>
<li>进程在时间片结束前阻塞或者结束，cpu切换另一个进程</li>
</ul>
</li>
</ul>
<h4 id="最高优先级调度算法（Highest-Priority-First，HPF）"><a href="#最高优先级调度算法（Highest-Priority-First，HPF）" class="headerlink" title="最高优先级调度算法（Highest Priority First，HPF）"></a>最高优先级调度算法（<strong>Highest Priority First</strong>，<strong>HPF</strong>）</h4><blockquote>
<p>从就绪队列中选择优先级最高的进程运行</p>
</blockquote>
<p>进程的优先级可以分为，静态优先级和动态优先级：</p>
<ul>
<li>静态优先级：进程创建时就已经确定了优先级，后续运行时间内无法改变</li>
<li>动态优先级：根据进程的动态变化调整优先级（如：随着时间的推移增加等待进程的优先级。）</li>
</ul>
<p>处理优先级高的方法也分为，抢占式和非抢占式：</p>
<ul>
<li>抢占式：就绪队列中出现优先级高的进程时，挂起当前进程，运行优先级高的进程</li>
<li>非抢占式：就绪队列中出现优先级高的进程时，运行完当前进程，再选择优先级高的进程</li>
</ul>
<h3 id="多级反馈队列调度算法（Multilevel-Feedback-Queue）"><a href="#多级反馈队列调度算法（Multilevel-Feedback-Queue）" class="headerlink" title="多级反馈队列调度算法（Multilevel Feedback Queue）"></a>多级反馈队列调度算法（<strong>Multilevel Feedback Queue</strong>）</h3><p>结合了「时间片轮转调度」和「最高优先级调度」算法</p>
<p>先设置了多个队列，<strong>高优先级队列</strong>内的进程<strong>优先被处理</strong>，与此同时越高优先级队列所<strong>分配的时间片也越短</strong></p>
<p><img src="/2021/10/21/Operating_system/Process_scheduling_2.png"></p>
<blockquote>
<p>ps:随便整了张图来体会体会</p>
</blockquote>
<p>尝试通过举一个例子来阐述这种调度算法：</p>
<ul>
<li><strong>进程A</strong>进入队列，此时没有进程在处理，将进程A放入最高优先级队列<code>Q1</code>中（<strong>先来先服务</strong>）</li>
<li>过一段时间后，<strong>进程B</strong>进入队列<ul>
<li>此时若<strong>进程A</strong>在队列<code>Q1</code>所规定的时间片内未运行完成，则将<strong>进程A</strong>放入次一级队列<code>Q2</code>等待运行（就绪状态）</li>
<li>若<strong>进程A</strong>能在<code>Q1</code>所规定的时间片运行完成，则进程B进入<code>Q1</code>队列等待运行</li>
</ul>
</li>
<li>再过一段时间后，<strong>进程C</strong>进入队列<ul>
<li>此时若<strong>进程B</strong>在<code>Q1</code>中运行，进程A在Q2中等待，则将<strong>进程C</strong>放入<code>Q1</code>队列中等待运行</li>
<li>当进程B运行完成后，由于<strong>进程C</strong>所在的<code>Q1</code>队列优先级比进程A所在的<code>Q2</code>队列高，所以优先调度<strong>进程C</strong>运行</li>
</ul>
</li>
</ul>
<hr>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Gmall开发笔记</title>
    <url>/2021/10/20/Gmall_eassy/</url>
    <content><![CDATA[<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>学习完springCloud后的自学项目，记载一些开发学习过程中的心得</p>
<span id="more"></span>

<h2 id="Gmall开发笔记"><a href="#Gmall开发笔记" class="headerlink" title="Gmall开发笔记"></a>Gmall开发笔记</h2><h3 id="10-20"><a href="#10-20" class="headerlink" title="10.20"></a>10.20</h3><p>修复了启动人人开发平台启动失败的问题，原因有如下几个方面：</p>
<ul>
<li>云服务器的mysql数据库端口未开放，之前配置好的安全组莫名没了？</li>
<li>在加入新模块或者对模块修改完进行<code>mvn clean/install</code>时会提示 <code>parent.relativePath‘ of POM io.renren:renren-generator:1.0.0</code>,于是乎发现pom.xml是<strong>parent依赖</strong>未加入<relativePath><ul>
<li><relativePath>的作用是查找父项目<strong>pom.xml</strong>的相对路径，缺少这个标签时，可能会无法从当前pom文件的上一级目录去查找，即可能会无法继承父模块中的包<strong>version</strong>信息</relativePath></li>
</ul>
</relativePath></li>
<li>关于模块启动后显示主类无法找到<ul>
<li>尝试<code>mvn clean/install</code>,重新加载target文件</li>
<li>查看模块的启动配置是否正确</li>
<li>尝试刷新idea缓存并重启</li>
</ul>
</li>
</ul>
<h3 id="10-28"><a href="#10-28" class="headerlink" title="10.28"></a>10.28</h3><ul>
<li><p>使用<strong>Stream流</strong>来筛选数据(单表)，做了一个分级的排序(实在没想到Stream操作那么神奇)，谈谈使用Stream的一些场景：</p>
<ul>
<li>相比于iterator，较复杂的多步处理迭代逻辑，可以使用stream流以<strong>提高代码的简洁性</strong>，损失一些几乎没有的效率(浏览博客时看到别人做的实验)</li>
<li>多核cpu且数据量大的条件下推荐使用 paralle stream</li>
<li>注意stream中间操作时的频繁的拆、装箱操作</li>
</ul>
</li>
<li><p>在后台管理系统，显示后端获取的分级排序后的数据时，遇到了<strong>跨域</strong>的问题，解决方案如下：</p>
<ul>
<li>通过配置config类，添加CorsFilter和CorsConfiguration方法，放行允许的请求</li>
<li>在Controller层上添加<code>@CrossOrigin</code>注解</li>
<li>也可以通过修改请求头等信息</li>
</ul>
</li>
<li><p>使用Feign测试了两个服务模块间的服务调用</p>
</li>
<li><p>后台管理系统的前端使用了Vue和ElementUI，花了一点时间复习了两者的使用</p>
</li>
</ul>
<h3 id="10-31"><a href="#10-31" class="headerlink" title="10.31"></a>10.31</h3><ul>
<li>使用阿里云oss三方服务，完成了后台管理系统<strong>图片</strong>的上传<br><img src="/2021/10/20/Gmall_eassy/10.31.png"></li>
</ul>
<p>oss服务的相关信息<strong>存储在后端</strong>中，前端向后端请求签名信息后，拿着签名信息直接在前端将图片存储到oss中，其中图片在oss中的地址存储在数据库中(<strong>服务端签名后直传</strong>的方式减轻了服务端的压力，并保存了oss服务)</p>
<ul>
<li>关于非法数据的校验<ul>
<li>前端的校验只能督促用户输入合法信息，但是通过postman等方式可以绕过前端发送非法信息</li>
<li>后端的字段校验能<strong>避免</strong>绕过前端方式发送非法请求，在后端<strong>Entity类</strong>字段上采用<code>javax.validation.constraints</code>包的<strong>注解校验</strong></li>
</ul>
</li>
</ul>
<h3 id="11-5"><a href="#11-5" class="headerlink" title="11.5"></a>11.5</h3><ul>
<li><p>关于Entity，分出一个vo来细化操作，在浏览<strong>阿里Java开发手册</strong>的时候，也了解到针对不同层、逻辑专门区分有不同的对象如下：</p>
<ul>
<li> <code>POJO</code>（Plain Ordinary Java Object）: 在本规约中，POJO 专指只有 setter/getter/toString 的</li>
</ul>
<p>简单类，包括 DO/DTO/BO/VO 等。</p>
<ul>
<li><p> <code>DO</code>（Data Object）：阿里巴巴专指数据库表一一对应的 POJO 类。此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。</p>
</li>
<li><p> <code>DTO</code>（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。</p>
</li>
<li><p><code>BO</code>（Business Object）：业务对象，可以由 Service 层输出的封装业务逻辑的对象。</p>
</li>
<li><p><code>VO</code>（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</p>
</li>
<li><p><code>AO</code>（Application Object）: 阿里巴巴专指 Application Object，即在 Service 层上，极为贴近</p>
<p>业务的复用代码。</p>
</li>
<li><p><code>DO</code>（Data Object）：阿里巴巴专指数据库表一一对应的 POJO 类。此对象与数据库表结构一</p>
<p>一对应，通过 DAO 层向上传输数据源对象。</p>
</li>
</ul>
<p>之前在第一次做curd的业务操作时，全部对象都放在一个POJO包里，不同业务的entity都放在一个包里，开发起来<strong>十分不方便</strong></p>
</li>
<li><p>关于商品的常用信息，添加了一个枚举类来定义常用的信息，如关于采购信息：</p>
<ul>
<li><pre><code class="java">CREATED(0,&quot;新建&quot;),ASSIGNED(1,&quot;已分配&quot;),
RECEIVE(2,&quot;已领取&quot;),FINISH(3,&quot;已完成&quot;),
HASERROR(4,&quot;有异常&quot;);
</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>在使用时是<code>purchaseEntity.setStatus(WareConstant.PurchaseStatusEnum.CREATED.getCode());</code></p>
<p>虽然可以直接写<code>purchaseEntity.setStatus(0)</code>等，但是这样抽取一个<strong>通用类</strong>在<strong>逻辑上能更加直观？</strong>个人也倾向于使用前者。</p>
</li>
<li><p>关于业务代码，在业务代码部分，并没有详细的看，大多是囫囵吞枣，</p>
<ul>
<li>主要是根据接口手册，确定数据接收类型</li>
<li>在service层通过<code>mybatisplus</code>+<code>Stream流式编程</code>的代码风格来实现crud<ul>
<li>之前开发service层时，图方便使用的是<strong>mybatis注解开发方式</strong>，注解开发个人感觉后期不好维护，而<code>mybatisplus</code>+<code>Stream流式编程</code>的方式感觉代码维护起来方便很多，对于相对应的操作也直接明了</li>
<li>关于mybatis，在学习spring和springboot的时候，感觉<strong>xml配置</strong>的方式逐渐会被淘汰，注解开发才是趋势？但是<strong>针对特定需求</strong>的查询操作等，感觉还是需要mybatis的</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>关于商城基础篇的学习已经结束，后续还有让人打鸡血的微服务和部署篇，ES分布式搜索引擎、redis实现分布式锁、看了一次都看不懂的缓存一致性、学了还没用上的消息队列、好玩的ci/cd等哈哈哈哈哈，开车开冲！</p>
</blockquote>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Gmall</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql最左匹配原则</title>
    <url>/2021/10/15/Mysql_LeftmostMatchingPrinciple/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>在群和大佬们吹水的时候了解到最左匹配原则，于是乎想琢磨一下，在这里整理一下自己了解的内容</p>
<span id="more"></span>

<blockquote>
<p>开门见山，顾名思义:</p>
<p>在Mysql建立联合索引时，利用该联合索引检索数据时会优先从索引最左列开始匹配</p>
<p>在创建多列索引时，要根据业务需求，where子句中使用<strong>最频繁的一列</strong>放在<strong>最左边</strong>。</p>
</blockquote>
<p>浏览了一些博客，总结出一些内容如下：</p>
<h3 id="为什么叫最左匹配原则？"><a href="#为什么叫最左匹配原则？" class="headerlink" title="为什么叫最左匹配原则？"></a>为什么叫最左匹配原则？</h3><p>索引的底层是一颗b+树，针对联合索引(a,b)来说，联合索引的底层也是一个B+树，那构建一个B+树只能通过一个值<br>来构建</p>
<p>那联合索引(多个值)怎么办呢？那就通过最左匹配原则，优先根据a来构建一个索引b+树，图大致如下：<br><img src="/2021/10/15/Mysql_LeftmostMatchingPrinciple/5.png"><br>可以看到，对于多值的联合索引，优先根据最左边的值(a)进行排序，其次根据右边的值(b)排序，类似于<code>ORDER BY a，b</code></p>
<p>光说不如多做:<br><img src="/2021/10/15/Mysql_LeftmostMatchingPrinciple/6.png"><br><img src="/2021/10/15/Mysql_LeftmostMatchingPrinciple/3.png"><br><img src="/2021/10/15/Mysql_LeftmostMatchingPrinciple/4.png"><br>可以看见，当sql使用到索引a时，根据最左匹配原则定位到联合索引(a，b)的a(因为a是有序的)，通过<code>EXPLAIN</code>查看到<code>type</code>是<strong>ref</strong>(效率快过index)</p>
<p>而只使用到索引b时(无法根据其a的值进行最左匹配)，其<code>type</code>是<strong>index</strong>(按照全表索引顺序依次扫描)</p>
<h3 id="范围查询和模糊查询是否存在最左匹配呢？"><a href="#范围查询和模糊查询是否存在最左匹配呢？" class="headerlink" title="范围查询和模糊查询是否存在最左匹配呢？"></a>范围查询和模糊查询是否存在最左匹配呢？</h3><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><p><strong>只有</strong>对联合索引最左列进行查询才会使用到B+树索引</p>
<ul>
<li><p>联合索引下的B+树是优先按照最左列的字段进行排序的</p>
</li>
<li><p>考虑<code>SELECT * FROM table WHERE a&gt;1 AND a&lt;10 AND b&gt;1</code>的情况是否会用到联合索引呢？</p>
<ul>
<li>不一定，在[1,10]的范围内，b的顺序并不是有序的,例子：(1,5)和(2,1)，a按照顺序1、2最左匹配优先排序的情况下，b的顺序是5，1</li>
</ul>
</li>
</ul>
<h4 id="字符串查询"><a href="#字符串查询" class="headerlink" title="字符串查询"></a>字符串查询</h4><p>上面的例子都是对数字类型的举例，根据大小进行排序，那<strong>字符型</strong>呢？</p>
<p>优先根据第一个字符的大小进行排序，其次根据第二个字符的大小，字符小的排序在前面(根据ASCII码?这里埋个坑，有时间来填)</p>
<p>故只有前缀匹配能是使用索引，中缀和后缀只能使用全表扫描</p>
<h3 id="sql中字段顺序是否要和联合索引顺序一样呢？"><a href="#sql中字段顺序是否要和联合索引顺序一样呢？" class="headerlink" title="sql中字段顺序是否要和联合索引顺序一样呢？"></a>sql中字段顺序是否要和联合索引顺序一样呢？</h3><p>mysql中具有<strong>查询优化器</strong>，都知道sql的实际执行顺序并不是我们表面上看到的从SELECT开始<br>对于建立了联合索引(a,b)的sql来说，通过EXPLAIN可以查看到两者的查询执行计划是一样的<br><img src="/2021/10/15/Mysql_LeftmostMatchingPrinciple/1.png"><br><img src="/2021/10/15/Mysql_LeftmostMatchingPrinciple/2.png"></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode每日亿题</title>
    <url>/2021/10/09/LeetCodeDaily/</url>
    <content><![CDATA[<h1 id="LeetCode每日亿题"><a href="#LeetCode每日亿题" class="headerlink" title="LeetCode每日亿题"></a>LeetCode每日亿题</h1><p>记录下自己解题的想法和思路。<br>每天进步亿点点，妈妈夸我小天才</p>
<span id="more"></span>


<h2 id="187-重复的DNA序列"><a href="#187-重复的DNA序列" class="headerlink" title="187. 重复的DNA序列"></a><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></h2><p>思路：</p>
<p>滑动窗口模拟，每次取长度为十的字符串</p>
<p>两个HashSet集合，<code>setStr</code>维护每次存入的字符串，<code>setAns</code>维护已出现过的字符串</p>
<p>最后用<code>listString</code>来接收<code>setAns</code>的结果集并return即可</p>
<pre><code class="java">class Solution &#123;
    static final int L = 10;
    public List&lt;String&gt; findRepeatedDnaSequences(String s) &#123;
        Set&lt;String&gt; setStr = new HashSet&lt;String&gt;();
        Set&lt;String&gt; setAns = new HashSet&lt;String&gt;();
        for(int i = 0; i &lt;= s.length() - L; i++)&#123;
            String str = s.substring(i,i+L);
            if(setStr.contains(str))&#123;
                setAns.add(str);
            &#125;else&#123;
                setStr.add(str);
            &#125;
        &#125;
        List&lt;String&gt; listString = new ArrayList&lt;String&gt;();
        for(String ans : setAns)&#123;
            listString.add(ans);
        &#125;
        return listString;
    &#125;
&#125;
</code></pre>
<p>结果：</p>
<p><img src="/2021/10/09/LeetCodeDaily/187.png"></p>
<blockquote>
<p>官解给的方法一写的更巧妙，可以去看看</p>
</blockquote>
<h2 id="352-将数据流变为多个不相交区间"><a href="#352-将数据流变为多个不相交区间" class="headerlink" title="352. 将数据流变为多个不相交区间"></a><a href="https://leetcode-cn.com/problems/data-stream-as-disjoint-intervals/">352. 将数据流变为多个不相交区间</a></h2><p>思路：</p>
<p>用一个boolean的数组维护数据流输入情况</p>
<p>用两个哨兵first和last来判断连续的区间情况并将存入到一个ArrayList中</p>
<p>最后将ArrayList类型转换为一个二维数组return即可</p>
<pre><code class="Java">class SummaryRanges &#123;
    static final int NUM = 10001;
    public boolean[] arr = new boolean[NUM];
    public SummaryRanges() &#123;
    &#125;
    public void addNum(int val) &#123;
        arr[val] = true;
    &#125;
    public int[][] getIntervals() &#123;
        List&lt;int[]&gt; res = new ArrayList&lt;int[]&gt;();
        int first = -1;
        int last = -1;
        for(int i = 0 ;i &lt;= 10000;i++)&#123;
            if(arr[i])&#123;
                if(first == -1)&#123;
                    first = i;
                    last = i;
                &#125;else last = i;
            &#125;else&#123;
                if(first != -1)&#123;
                    res.add(new int[]&#123;first,last&#125;);
                    first = -1;
                    last = -1;
                &#125;
            &#125;
        &#125;
        if(first != -1)&#123;
             res.add(new int[]&#123;first,last&#125;);
        &#125;
        return res.toArray(new int[res.size()][2]);
    &#125;
&#125;
</code></pre>
<p>时间复杂度：<code>addNum()</code> 为 O(1)<em>O</em>(1)，<code>getIntervals()</code> 为 O(C)，C 固定为10001。</p>
<p>空间复杂度：O(C)，C 固定为10001。</p>
<p>结果如图：</p>
<p><img src="/2021/10/09/LeetCodeDaily/352.png"></p>
<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h2><p>思路：</p>
<p>刚开始直接暴力法，时间复杂度为<strong>O(N3)</strong>,还得考虑去重的步骤，看了题解不如直接使用<strong>排序+双指针</strong>，能将时间复杂度降到O(N2)</p>
<p>先将数组排序，时间复杂度<strong>O(NlogN)</strong></p>
<p>然后固定数组最左端指针<code>i</code>，在<code>i</code>右端使用两个动态指针<code>j、k</code>移动，将三数之和与零进行比较：</p>
<ul>
<li>等于零时，将结果添加进List集合中，然后<code>j</code>指针向右移，<code>k</code>指针向左移</li>
<li>大于零时，<code>k</code>指针向左移且去重</li>
<li>小于零时，<code>j</code>指针向右移动且去重</li>
</ul>
<p>代码：</p>
<pre><code class="java">class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;
        Arrays.sort(nums);
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList();
        int length = nums.length;
        for(int i = 0 ; i &lt; length-2; i++)&#123;
            if(nums[i] &gt; 0) break;
            if(i&gt;0 &amp;&amp; nums[i] == nums[i-1]) continue;
            int j = i+1; //左指针
            int k = length-1; //右指针
            while(j&lt;k)&#123;
                int total = nums[i] + nums[j] + nums[k];
                if(total&gt;0)&#123;
                    //去重且向左移
                    while(j&lt;k &amp;&amp; nums[k] == nums[--k]);
                &#125;else if(total&lt;0)&#123;
                    //去重且向右移
                    while(j&lt;k &amp;&amp; nums[j] == nums[++j]);
                &#125;else &#123;
                    res.add(new ArrayList&lt;Integer&gt;(Arrays.asList(nums[i],nums[j],nums[k])));
                    while(j&lt;k &amp;&amp; nums[k] == nums[--k]);
                    while(j&lt;k &amp;&amp; nums[j] == nums[++j]);
                &#125;
            &#125;   
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<p>时间复杂度： <strong>O(N2)<strong>，固定指针<code>i</code>复杂度</strong>O(N)</strong>,动态双指针<code>i</code>、<code>j</code>**O(N)**的复杂度</p>
<p>空间复杂度：**O(1)**，指针占用常数大小空间</p>
<p>结果如图：</p>
<p><img src="/2021/10/09/LeetCodeDaily/15.png"></p>
<blockquote>
<p>代码中最令人感叹的是指针去重且移动的操作：</p>
<p>如：<code>while(j&lt;k &amp;&amp; nums[k] == nums[--k]);</code></p>
<p>每次看大佬题解都感觉受益匪浅</p>
</blockquote>
<h2 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h2><p>思路：</p>
<ul>
<li>模拟填入过程：<ul>
<li>设立<strong>上下左右</strong>四个边界，上、左边界初始值为0，右、下边界初始值为n-1</li>
<li>始终按照四个方向：从左到右、从上到下、从右到左、从下到上<ul>
<li>填入数字达到边界后，对应的边界向内缩小</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="Java">class Solution &#123;
    public int[][] generateMatrix(int n) &#123;
        int[][] res = new int[n][n];
        int count = 1,num = n * n;
        int left = 0,top = 0,right = n-1,down = n-1; //左上右下四个边界
        while(count &lt;= num)&#123;
            for(int i =left;i &lt;= right;i++) res[top][i] = count++;//左边界left到右边界right，top行填完后top++
            top++;
            for(int i =top;i &lt;= down;i++) res[i][right] = count++;//上边界top到下边界down，right列填完后right--
            right--;
            for(int i =right;i &gt;= left;i--) res[down][i] = count++;//右边界right到左边界left，down行填完后down--
            down--;
            for(int i =down;i &gt;= top;i--) res[i][left] = count++;//下边界down到上边界top，left列填完后left++
            left++;
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<p>运行结果：<br><img src="/2021/10/09/LeetCodeDaily/59.png"></p>
<h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a></h2><p>思路：</p>
<ul>
<li>按照数组右区间大小升序排序，参考大佬<strong>代码随想录</strong>的一张图：<img src="/2021/10/09/LeetCodeDaily/435_1.png"><ul>
<li>使用右区间最小数组1依次向右判断，当达到数组4时符合条件<code>count++</code>,此时从数组4继续向右判断</li>
</ul>
</li>
<li>根据条件判断出符合条件的区间数量<code>count</code>，则剩下的就是需要移除的区间数量</li>
</ul>
<pre><code class="java">class Solution &#123;
    public int eraseOverlapIntervals(int[][] intervals) &#123;
        if(intervals.length == 0) return 0;
        Arrays.sort(intervals,(a,b) -&gt; a[1] - b[1]);
        int count = 1;
        int num = intervals[0][1];
        for(int i = 1 ;i &lt; intervals.length; i++)&#123;
            if(num &lt;= intervals[i][0])&#123;
                num = intervals[i][1];
                count++;
            &#125;
        &#125;
        return intervals.length - count;
    &#125;
&#125;
</code></pre>
<p>时间复杂度：<strong>O(nlogn)</strong>,有一个快排</p>
<p>空间复杂度：<strong>O(1)</strong></p>
<p>结果如图：<br><img src="/2021/10/09/LeetCodeDaily/435_2.png"></p>
<h2 id="29-两数相除"><a href="#29-两数相除" class="headerlink" title="29. 两数相除"></a><a href="https://leetcode-cn.com/problems/divide-two-integers/">29. 两数相除</a></h2><p>思路：</p>
<ul>
<li>减法，被除数循环减去除数，但是效率比较低<ul>
<li>位运算，计算机进行位运算时的效率比较高，通过右位移找出满足**<code>2^i</code><em>除数&lt;=被除数*<em>最大的<code>i</code>,此时被除数减去</em></em><code>2^i</code>*除数**，再找剩下满足条件的<code>i</code>,以此类推</li>
<li>举个例子，100/6—&gt; <em><em><code>2^4</code><em>6&lt;=100</em></em>,此时最大的<code>i</code>是4,剩下的100-96 = 4无法满足</em><em><code>2^i</code><em>除数&lt;=被除数</em></em>,则商为16</li>
</ul>
</li>
</ul>
<p>代码：</p>
<pre><code class="java">class Solution &#123;
    public int divide(int dividend, int divisor) &#123;
        if(dividend == 0) return 0;
        if(dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1) return Integer.MAX_VALUE;
        boolean negative = (dividend ^ divisor) &lt; 0;//符号判断
        int res = 0;
        long num1 = Math.abs((long)dividend);
        long num2 = Math.abs((long)divisor);
        for(int i = 31 ; i &gt;= 0 ; i--)&#123; 
            if((num1 &gt;&gt; i) &gt;= num2)&#123; //找出最大的数divisor*2^n
                res += 1&lt;&lt;i;         //结果加上2^n
                num1 -= num2&lt;&lt;i;     //计算剩余被除数
            &#125;
        &#125;
        return negative ? -res:res;  //符号互异取反
    &#125;
&#125;
</code></pre>
<p>结果：</p>
<p><img src="/2021/10/09/LeetCodeDaily/29.png"></p>
<h2 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38. 外观数列"></a><a href="https://leetcode-cn.com/problems/count-and-say/">38. 外观数列</a></h2><p>思路：</p>
<ul>
<li><p>使用双指针，截取<strong>相同字符</strong>的每个组，按照题意模拟即可</p>
<ul>
<li>依次遍历每个组</li>
<li>依次填入<code>n</code>(指针下标<strong>相减</strong>)个<code>m</code>（填入<strong>first</strong>指针的数）</li>
<li>进行下一次遍历</li>
</ul>
</li>
</ul>
<p>代码：</p>
<pre><code class="java">class Solution &#123;
    public String countAndSay(int n) &#123;
        String str = &quot;1&quot;;
        for(int i = 2; i &lt;= n ; i++)&#123;
            int first = 0 ,last = 0;
            StringBuffer sb = new StringBuffer();
            while(last &lt; str.length())&#123;
                while(last &lt; str.length() &amp;&amp; str.charAt(first) == str.charAt(last)) last++;
                sb.append(Integer.toString(last - first)).append(str.charAt(first));
                first = last;
            &#125;
            str = sb.toString();
        &#125;
        return str;
    &#125;
&#125;
</code></pre>
<p>结果：</p>
<p><img src="/2021/10/09/LeetCodeDaily/38.png"></p>
<p>时间复杂度：O(N*M),N-&gt;给定正整数n，M-&gt;生成字符串长度</p>
<p>空间复杂度：O(M)，M-&gt;生成字符串长度</p>
<h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a href="https://leetcode-cn.com/problems/partition-labels/">763. 划分字母区间</a></h2><p>思路：</p>
<ul>
<li>最难的是如何划分好符合条件的片段<ul>
<li>先用一个<strong>数组</strong>记录每个字母的最远下标(也可以用<strong>HashMap</strong>来记录)</li>
<li>用两个下标截取片段<ul>
<li>当前遍历字母的最远下标一定是在当前片段中，即<code>end</code>大于等于当前字母的最远下标</li>
<li>当遍历<code>i</code>访问到下标<code>end</code>时，这个片段即是符合条件的片段(贪心)</li>
</ul>
</li>
<li>将当前片段结果加入结果集，进行后续片段的遍历</li>
</ul>
</li>
</ul>
<p>代码：</p>
<pre><code class="java">class Solution &#123;
    public List&lt;Integer&gt; partitionLabels(String s) &#123;
        int len = s.length();
        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
        int[] arr = new int[26];
        for(int i = 0 ; i &lt; len ; i++)&#123;
            arr[s.charAt(i) - &#39;a&#39;] = i; //记录字母最远下标
        &#125; 
        int start = 0, end = 0;
        for(int i = 0 ; i &lt; len ; i++)&#123;
            end = Math.max(end,arr[s.charAt(i) - &#39;a&#39;]); //当前遍历字母的最远下标一定是在当前片段中
            if(i == end)&#123;
                res.add(end - start + 1);
                start = end + 1;
            &#125;
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<p>结果：</p>
<p><img src="/2021/10/09/LeetCodeDaily/763.png"></p>
<p>时间复杂度：log(N),遍历两次数组</p>
<p>空间复杂度：log(m),m是字符串中的字符集，这题中m为26(只包含26个小写字母)</p>
<blockquote>
<p>Tips：</p>
<p>对于贪心的思想掌握的还是不够好，以局部最优求出全局最优。</p>
</blockquote>
<h2 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a><a href="https://leetcode-cn.com/problems/multiply-strings/">43. 字符串相乘</a></h2><p>思路：</p>
<p>将乘数每一位和被乘数<strong>相乘累加</strong>的结果放入对应数组中，乘数和被乘数长度分别为<code>en1</code>和<code>len2</code>，故数组的大小不超过<strong>len1+len2</strong>（例如100 * 100 = 1000，3 + 3 &gt;= 4 ）</p>
<ul>
<li>两个for循环得到结果数组后，还得对数组进行操作才能获得最终数组(模拟乘法)<ul>
<li>数组下标从右到左，将当前数组下标的值与10除<strong>取商</strong>累加到左一位</li>
<li>当前数组下标与10除<strong>取余</strong></li>
</ul>
</li>
<li>获得最终数组后，判断数组arr[0]为0或1进行字符串拼接操作（题目要求不以0开头）</li>
</ul>
<p>代码：</p>
<pre><code class="java">class Solution &#123;
    public String multiply(String num1, String num2) &#123;
        if(num1.equals(&quot;0&quot;) || num2.equals(&quot;0&quot;)) return &quot;0&quot;;
        
        int len1 = num1.length(),len2 = num2.length();
        int[] arr = new int[len1 + len2];

        for(int i = len1 - 1; i &gt;= 0; i--)&#123;
            int curnum1 = num1.charAt(i) - &#39;0&#39;;
            for(int j = len2 - 1; j &gt;= 0; j--)&#123;
                int curnum2 = num2.charAt(j) - &#39;0&#39;;
                arr[i + j + 1] += curnum1 * curnum2;
            &#125;
        &#125;

        for(int k = len1 + len2 -1 ; k &gt; 0; k--)&#123;
            arr[k - 1] += arr[k]/10;
            arr[k] %= 10;
        &#125;

        int index = arr[0] == 0 ? 1 : 0;
        StringBuffer res = new StringBuffer();
        while(index &lt; len1 + len2)&#123;
            res.append(arr[index]);
            index++;
        &#125;
        return res.toString();
    &#125;
&#125;
</code></pre>
<p>结果：</p>
<p><img src="/2021/10/09/LeetCodeDaily/43.png"></p>
<p>时间复杂度：<strong>O(m*n)</strong>,其中<code>m</code>和<code>n</code>分别是<code>num1</code>和<code>num2</code>的长度</p>
<p>空间复杂度：**O(m+n)**，</p>
<h2 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h2><p>思路：</p>
<p>因为是二叉搜索树，所以可以用栈按中序遍历来访问二叉树</p>
<p>代码：</p>
<pre><code class="java">class Solution &#123;
    public int kthSmallest(TreeNode root, int k) &#123;
        Deque&lt;TreeNode&gt; stk = new LinkedList&lt;&gt;();
        while(root != null|| !stk.isEmpty())&#123;
            while(root != null)&#123;
                stk.push(root);
                root = root.left;
            &#125;
            root = stk.pop();
            k--;
            if( k == 0 )&#123;
                break;
            &#125;
            root = root.right;
        &#125;
        return root.val;
    &#125;
&#125;
</code></pre>
<p>结果：</p>
<p><img src="/2021/10/09/LeetCodeDaily/230.png"></p>
<p>时间复杂度：<code>O(H+k)</code>,H是树的高度,当树是平衡树时，可以取<code>O(logN+k)</code></p>
<p>空间复杂度：<code>O(H)</code>,栈中最多存H个元素</p>
<blockquote>
<p>Tips;</p>
<p>记录这题的目的是自从学习数据结构后很久没做树的题目了，最近开始刷题时遇到的第一道树的题目，故记录下来。</p>
</blockquote>
<h2 id="211-添加与搜索单词-数据结构设计"><a href="#211-添加与搜索单词-数据结构设计" class="headerlink" title="211. 添加与搜索单词 - 数据结构设计"></a><a href="https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/">211. 添加与搜索单词 - 数据结构设计</a></h2><p>思路：</p>
<p>简单暴力的方法</p>
<ul>
<li>用<strong>HashMap</strong>存**<code>键：值</code><strong>为</strong><code>字符串长度：相同长度下不同的单词</code>**</li>
<li>查找的时候，从<strong>HashMap</strong>取出相同长度下的<strong>set集合</strong><ul>
<li>先考虑不带 <code>&#39;.&#39;</code>的单词</li>
<li>对于含有 <code>&#39;.&#39;</code>的单词再拆放入数组中逐个比较</li>
</ul>
</li>
</ul>
<p>代码：</p>
<pre><code class="java">class WordDictionary &#123;
    Map&lt;Integer,Set&lt;String&gt;&gt; map = new HashMap&lt;&gt;();//根据字符串长度分开存放
    public WordDictionary() &#123;
        
    &#125;
    public void addWord(String word) &#123;
        int len = word.length();
        if(map.get(len) != null)&#123;
            map.get(len).add(word);
        &#125;else&#123;
            Set&lt;String&gt; set = new HashSet&lt;&gt;();
            set.add(word);
            map.put(len,set);
        &#125;
    &#125;
    public boolean search(String word) &#123;
        Set&lt;String&gt; set = map.get(word.length());
      
        if(set == null) return false;
        if(set.contains(word)) return true;
      
        char[] charword = word.toCharArray(); 
        P:for(String str : set)&#123;
            if(str.length() != word.length()) continue;
            char[]  charstr = str.toCharArray();
            for(int i = 0 ; i &lt; word.length(); i++)&#123; //每个字符比较
                if(charword[i] != &#39;.&#39; &amp;&amp; charword[i] != charstr[i]) continue P; //遍历下一个字符
            &#125;
            return true;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<p>结果：</p>
<p><img src="/2021/10/09/LeetCodeDaily/211.png"></p>
<blockquote>
<p>该题的官方解法是使用前缀树进行求解</p>
</blockquote>
<h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串</a></h2><p>思路：</p>
<p>回文字符串，可以按照<strong>回文中心向两侧延伸</strong>的思路来查找有多少个回文字符串</p>
<ul>
<li>回文中心，按照奇偶的区分来说，回文中心不是单个字符就是两个同样的字符如<code>a</code>或<code>aa</code>,当三个字符的情况可以视作为一个回文串</li>
<li>其次，回文中心的数量按照观察来说，有<code>2*len-2</code>个(其中len为字符串长度)</li>
<li>最后可以定义两个指针向两侧延伸<ul>
<li>当回文中心为奇数时，两指针重叠</li>
<li>当回文中心为偶数时，两指针一左一右</li>
</ul>
</li>
</ul>
<p>代码：</p>
<pre><code class="java">class Solution &#123;
    public int countSubstrings(String s) &#123;
        int len = s.length(), ans = 0;
        for (int i = 0; i &lt; 2 * len - 1; ++i) &#123;
            int l = i / 2, r = i / 2 + i % 2;
            while (l &gt;= 0 &amp;&amp; r &lt; len &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;
                --l;
                ++r;
                ++ans;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;
</code></pre>
<p>结果：</p>
<p><img src="/2021/10/09/LeetCodeDaily/647.png"></p>
<p>时间复杂度：<strong>O(n^2)</strong>,枚举回文中心<strong>O(n)</strong>,指针延展查找回文子串<strong>O(n)</strong></p>
<p>空间复杂度：<strong>O(1)</strong></p>
<h2 id="229-求众数-II"><a href="#229-求众数-II" class="headerlink" title="229. 求众数 II"></a><a href="https://leetcode-cn.com/problems/majority-element-ii/">229. 求众数 II</a></h2><p>先放上代码</p>
<pre><code class="Java">class Solution &#123;
    public List&lt;Integer&gt; majorityElement(int[] nums) &#123;
        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        int count = 0,len = nums.length;
        for(int num : nums)&#123;
            map.put(num,map.getOrDefault(num,0)+1);
        &#125;
        for (Integer key : map.keySet()) &#123;
            if(map.get(key) &gt; len/3) res.add(key);
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<p>这是时间复杂度和空间复杂度均为**O(n)**的解法,其中<code>n</code>为数组的长度</p>
<p>但是题目的进阶要求是把空间复杂度优化到<strong>O(1)</strong>,题解给了一种很神奇的方法——<strong>摩尔投票法</strong>,思路如下：</p>
<ul>
<li><p>题目要求找出超过【n/3】的元素，实际上隐含了一个条件——结果集内只有两个结果</p>
</li>
<li><p>大致cv一下摩尔投票法的思路</p>
<ul>
<li>选票数超过一半的候选人时，投票结果如数组【A,B,C,C,C,A】</li>
<li>第一张票和第二张票不同，分别为A和B，互相抵消</li>
<li>第三四五张票相同，则增加C候选人可以抵消的票数</li>
<li>后面还有一张A抵消C一次，此时候选人是C，则统计一下C在数组中出现的次数，超过一半则候选人是C</li>
</ul>
</li>
<li><p>可以看出摩尔投票法是一个抵消的思路，同时由票数<strong>超过1/2即被选取</strong>扩展一下至票数<strong>超过1/n时被选取</strong>，则最理想情况下会有<strong>n-1个被选取</strong></p>
</li>
</ul>
<p>贴上代码：</p>
<pre><code class="java">class Solution &#123;
    public List&lt;Integer&gt; majorityElement(int[] nums) &#123;
        // 创建返回值
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        if (nums == null || nums.length == 0) return res;
        // 初始化两个候选人candidate，和他们的计票
        int cand1 = nums[0], count1 = 0;
        int cand2 = nums[0], count2 = 0;

        // 摩尔投票法，分为两个阶段：配对阶段和计数阶段
        // 配对阶段
        for (int num : nums) &#123;
            // 投票
            if (cand1 == num) &#123;
                count1++;
                continue;
            &#125;
            if (cand2 == num) &#123;
                count2++;
                continue;
            &#125;

            // 第1个候选人配对
            if (count1 == 0) &#123;
                cand1 = num;
                count1++;
                continue;
            &#125;
            // 第2个候选人配对
            if (count2 == 0) &#123;
                cand2 = num;
                count2++;
                continue;
            &#125;

            count1--;
            count2--;
        &#125;

        // 计数阶段
        // 找到了两个候选人之后，需要确定票数是否满足大于 N/3
        count1 = 0;
        count2 = 0;
        for (int num : nums) &#123;
            if (cand1 == num) count1++;
            else if (cand2 == num) count2++;
        &#125;

        if (count1 &gt; nums.length / 3) res.add(cand1);
        if (count2 &gt; nums.length / 3) res.add(cand2);

        return res;
    &#125;
&#125;
</code></pre>
<p>时间复杂度依然是**O(n),<strong>但是空间复杂度已经只有</strong>O(1)**了</p>
<h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h2><blockquote>
<p>很经典的一道题，记录一下</p>
</blockquote>
<p>思路</p>
<p>官解说可以用<strong>Hashmap</strong>来存储中序遍历数组的下标，这样在后续递归中，中序遍历数组，定位根节点位置时时间复杂度只有O(1)，真是妙蛙种子吃着妙脆角妙进了米奇妙妙屋，妙到家了～</p>
<ul>
<li><p>根据<strong>先序遍历</strong>数组的<strong>第一位</strong>判断为根节点</p>
</li>
<li><p>根据根节点判断<strong>中序遍历</strong>的左子树和右子树</p>
<ul>
<li><p>递归传入下标时，注意子树左右边界：</p>
<ul>
<li><p>很显然中序遍历数组中查找到根节点后<strong>其左右分别是左右子树的区间</strong></p>
</li>
<li><p>先序遍历数组中<strong>最左下标对应的为根节点</strong>，根据中序遍历左侧数组下标来求得<strong>左子树数量</strong>，同理求得右<strong>子树数量</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>代码</p>
<pre><code class="java">class Solution &#123;
    Map&lt;Integer,Integer&gt; res = new HashMap&lt;&gt;();
    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;
        for(int i = 0 ; i &lt; inorder.length; i++)&#123;
            res.put(inorder[i],i); 
        &#125; 

        return makeTree(preorder,inorder,0,preorder.length - 1,0,inorder.length - 1);

    &#125;

    public TreeNode makeTree(int[] preorder, int[] inorder, int pre_left,int pre_right,int in_left,int in_right)&#123;

        if(pre_left &gt; pre_right) return null;
        //先序遍历数组的第一位即是根节点
        int pre_root = pre_left;

        //在中序遍历中定位根节点
        int in_root = res.get(preorder[pre_root]);

        //建立根节点
        TreeNode root = new TreeNode((preorder[pre_root]));

        //中序遍历数组根节点的左侧 -&gt; 得到左子树中节点的数目
        int size_left_subtree = in_root - in_left;

        //递归构造左子树
        root.left = makeTree(preorder,inorder,pre_left + 1,pre_left + size_left_subtree ,in_left,in_right - 1);

        //递归构造右子树
        root.right = makeTree(preorder,inorder,pre_left + size_left_subtree + 1,pre_right,in_root + 1,in_right);

        return root;
    &#125;
&#125;
</code></pre>
<p>时间复杂度：<strong>O(n)</strong>,n为树中节点的个数</p>
<p>空间复杂度：**O(n)**，n为HashMap的空间+返回结果的空间+递归时栈空间(树高度)</p>
<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><blockquote>
<p>最经典的BFS了</p>
<p>之前学数据结构时用c++实现的，现在时隔很久，正式开始算法时用java实现</p>
</blockquote>
<p>思路</p>
<p>迭代方法：</p>
<p>用一个队列来维护当前层的节点，用一个list集合来维护当前层节点的值，每遍历一次队列后，再将list集合添加进最终结果集中</p>
<ul>
<li>用**队列(queue)**来存放当前层的节点</li>
<li>在遍历<strong>队列</strong>(节点)时,临时创建一个**集合(ArrayList)**来存放每一层节点的值</li>
</ul>
<p>代码</p>
<pre><code class="java">class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;
        if(root==null) &#123;
            return new ArrayList&lt;List&lt;Integer&gt;&gt;();
        &#125;
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); //存放结果集
        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); //存放结点
        //将根节点放入队列中
        queue.add(root);
        while(queue.size()&gt;0) &#123;
            //获取当前队列的长度，这个长度相当于 当前这一层的节点个数
            int size = queue.size();
            ArrayList&lt;Integer&gt; tmp = new ArrayList&lt;Integer&gt;();
            //将队列中的元素都拿出来(也就是获取这一层的节点)，放到临时list中
            //如果节点的左/右子树不为空，也放入队列中
            for(int i=0;i&lt;size;++i) &#123;
                TreeNode t = queue.remove();
                tmp.add(t.val);
                if(t.left!=null) &#123;
                    queue.add(t.left);
                &#125;
                if(t.right!=null) &#123;
                    queue.add(t.right);
                &#125;
            &#125;
            //将临时list加入最终返回结果中
            res.add(tmp);
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<p>时间复杂度：<strong>O(N)</strong></p>
<p>空间复杂度：<strong>O(h)</strong>,h是树的高度</p>
<h2 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h2><blockquote>
<p>记录这题的目的是因为相比于暴力法O(n^2)的时间复杂度，有一种优化方法——单调栈法，时间复杂度可以优化到O(n+m)，这种方法也是专门解这一类题目的优化解法</p>
</blockquote>
<p>思路</p>
<ul>
<li>用一个<strong>HashMap</strong>来记录<code>nums2</code>数组中每个数其右边第一个比它大的数字<ul>
<li>用一个栈来逆序遍历<code>nums2</code>，记录比<code>nums2[i]</code>大的数,逆序遍历存入栈时，离<code>nums2[i]</code>右边最近的数在栈顶<ul>
<li>这一步是<strong>单调栈法</strong>的精华，妙到我无法用<strong>精炼的文字</strong>来描述，题目要求左边更大的元素时，就可以顺序遍历</li>
</ul>
</li>
</ul>
</li>
<li>在<strong>HashMap</strong>中查看<code>nums1</code>对应的结果</li>
</ul>
<p>代码</p>
<pre><code class="java">class Solution &#123;
    public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123;
        int n = nums1.length, m = nums2.length;
        Deque&lt;Integer&gt; d = new ArrayDeque&lt;&gt;();
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int i = m - 1; i &gt;= 0; i--) &#123;
            int x = nums2[i];
            while (!d.isEmpty() &amp;&amp; d.peekLast() &lt;= x) d.pollLast(); //比nums2[i]小的元素出栈
            map.put(x, d.isEmpty() ? -1 : d.peekLast());
            d.addLast(x);
        &#125;
        int[] ans = new int[n];
        for (int i = 0; i &lt; n; i++) ans[i] = map.get(nums1[i]);
        return ans;
    &#125;
&#125;
作者：AC_OIer
链接：https://leetcode-cn.com/problems/next-greater-element-i/solution/gong-shui-san-xie-yi-ti-shuang-jie-bian-n6nwz/
来源：力扣（LeetCode）
</code></pre>
<blockquote>
<p>代码转载自三叶姐，问就是她的暴力法写的太优雅了，自愧不如</p>
</blockquote>
<p>时间复杂度：<strong>O(m+n)</strong>, **O(m)**维护单调栈+O(n)构造答案</p>
<p>空间复杂度：<strong>O(m)</strong></p>
<h2 id="869-重新排序得到-2-的幂"><a href="#869-重新排序得到-2-的幂" class="headerlink" title="869. 重新排序得到 2 的幂"></a><a href="https://leetcode-cn.com/problems/reordered-power-of-2/">869. 重新排序得到 2 的幂</a></h2><blockquote>
<p>记录这题的目的是，很多时候并没有想出一个很好的解题思路(简单or简洁)，可能是题量还不够，思路还没扩展开来</p>
</blockquote>
<p>思路：</p>
<p>直接暴力回溯的， 在范围内满足<code>2 的幂</code>的数字不多</p>
<p>但是匹配上写的方法很乱，这里放上一种很好的思路</p>
<p><strong>词频统计</strong></p>
<ul>
<li>提前找出符合范围内满足<code>2 的幂</code>的数字，遍历每一个数字时，将该数字转换为num[对应位数字]{该数字出现次数}<ul>
<li>把给定<code>正整数N</code>转换为num[对应位数字]{该数字出现次数}</li>
<li>两个数组进行匹配</li>
</ul>
</li>
</ul>
<p>代码：</p>
<pre><code class="java">class Solution &#123;
    Set&lt;Integer&gt; res = new HashSet&lt;&gt;();

    public boolean reorderedPowerOf2(int n) &#123;
        for(int i = 1 ; i&lt;= (int)1e9+10; i*=2)&#123;
            res.add(i);
        &#125;

        int[] cnt = new int[10];
        while(n != 0)&#123;
            cnt[n%10]++;
            n /= 10;
        &#125;

        lo:for(int num : res)&#123;
            int[] resCnt = new int[10];
            while(num != 0)&#123;
                resCnt[num%10]++;
                num /= 10;
            &#125;

            for(int i = 0 ; i &lt; 10; i++)&#123;
                if(cnt[i] != resCnt[i]) continue lo;
            &#125;
            return true;
        &#125;
        return false;

    &#125;
&#125;
</code></pre>
<p>时间复杂度： O(C∗logn)</p>
<p>空间复杂度：O(C),C为数组空间大小</p>
<h2 id="1218-最长定差子序列"><a href="#1218-最长定差子序列" class="headerlink" title="1218. 最长定差子序列"></a><a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/">1218. 最长定差子序列</a></h2><p>思路</p>
<p>刚开始考虑使用<code>n^2</code>时间复杂度的暴力，一想可能会超时，遂打算用Hashmap来解决，但是自己对dp的学习还是不够深入，在转移方程上卡住了。。。</p>
<p>哈希表+DP</p>
<p>这题的关键是在于找到正确的转移方程：</p>
<ul>
<li><em>dp</em>[<em>v</em>]=<em>dp</em>[<em>v</em>−<em>d</em>]+1</li>
</ul>
<p>代码</p>
<blockquote>
<p>这里放的是官方的题解，问就是写的比我优雅简洁。。。</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    public int longestSubsequence(int[] arr, int difference) &#123;
        int ans = 0;
        Map&lt;Integer, Integer&gt; dp = new HashMap&lt;Integer, Integer&gt;();
        for (int v : arr) &#123;
            dp.put(v, dp.getOrDefault(v - difference, 0) + 1);
            ans = Math.max(ans, dp.get(v));
        &#125;
        return ans;
    &#125;
&#125;
</code></pre>
<p>时间复杂度：<em>O</em>(<em>n</em>)，其中 <em>n</em> 是数组 <em>arr</em> 的长度。</p>
<p>空间复杂度：<em>O</em>(<em>n</em>)。哈希表需要 O*(*n) 的空间。</p>
<h2 id="319-灯泡开关-数论"><a href="#319-灯泡开关-数论" class="headerlink" title="319. 灯泡开关 数论"></a><a href="https://leetcode-cn.com/problems/bulb-switcher/">319. 灯泡开关</a> 数论</h2><blockquote>
<p>很经典的数论题</p>
</blockquote>
<p>思路</p>
<p>首先，从约数下手，不难得出，约数为偶数的的灯泡，最后会熄灭，同理，约数为奇数的灯泡，最后会亮着。</p>
<p>然后，由约数的定义可得，对于数字<strong>k</strong>而言，如果他有约数x，那么一定有相对应的约数字<strong>y</strong>成对出现，使得<strong>k=x*y</strong>，同时，只有约数为<strong>「完全平方数」</strong>时，才会有<strong>奇数个</strong>的约数，否则则为<strong>偶数个</strong></p>
<p>举个🌰：</p>
<p>💡灯泡8⃣️的约数有：1、2、4、8，相对应的是-&gt;亮、灭、亮、灭</p>
<p>💡灯泡9⃣️的约数有：1、3、9，相对应的是-&gt;亮、灭、亮</p>
<p>最后，就是求给定n的约数，考虑到开方，结果向下取整。</p>
<p>代码</p>
<pre><code class="Java">class Solution &#123;
    public int bulbSwitch(int n) &#123;
        return (int)Math.floor(Math.sqrt(n));
    &#125;
&#125;
</code></pre>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(1)</p>
<h2 id="1143-最长公共子序列-动态规划"><a href="#1143-最长公共子序列-动态规划" class="headerlink" title="1143. 最长公共子序列 动态规划"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a> 动态规划</h2><p>思路</p>
<p>二维数组+DP</p>
<p>状态定义：<code>dp[i][j]</code>代表考虑text1 前<code>i</code>个字符、考虑text2前<code>j</code>个字符</p>
<p>那么对于「转移方程」来说</p>
<ul>
<li>当字符串<code>cs1[i] == cs[j]</code>：<code>dp[i][j] == dp[i-1][j-1] +1</code></li>
<li>当字符串<code>cs1[i] != cs[j]</code>：<code>dp[i][j]=max(dp[i][j-1],dp[i-1][j])</code></li>
</ul>
<blockquote>
<p>这里放一张官解的图</p>
</blockquote>
<p><img src="/2021/10/09/LeetCodeDaily/1143.png"></p>
<p>代码</p>
<pre><code class="java">class Solution &#123;
    public int longestCommonSubsequence(String text1, String text2) &#123;
        int n = text1.length(), m = text2.length();
        char[] cs1 = text1.toCharArray();
        char[] cs2 = text2.toCharArray();
        int[][] dp = new int[n + 1][m + 1];
        for(int i = 1; i &lt;= n;i++)&#123;
            for(int j = 1 ;j &lt;= m; j++)&#123;
                if(cs1[i-1] == cs2[j-1]) dp[i][j] = dp[i-1][j-1] + 1;
                else dp[i][j] = Math.max(dp[i][j-1],dp[i-1][j]); 
            &#125;
        &#125;
        return dp[n][m];
    &#125;
&#125;
</code></pre>
<p>时间复杂度：O(n * m)</p>
<p>空间复杂度：O(n * m)</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang入门</title>
    <url>/2021/10/02/Go/</url>
    <content><![CDATA[<h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><p>Go（又称Golang）是谷歌开发的一种具有并发型，简单性，并具有垃圾回收功能的静态强类型语言。</p>
<span id="more"></span>

<p>练习相关代码已经push到github上：<a href="https://github.com/Super-ZZGuo/FirstGo">https://github.com/Super-ZZGuo/FirstGo</a></p>
<h2 id="Golang-学习笔记"><a href="#Golang-学习笔记" class="headerlink" title="Golang 学习笔记"></a>Golang 学习笔记</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>定义长度</strong>的数组只能传给<strong>限制了相同数组长度</strong>的函数</p>
<p><strong>未定义长度</strong>的数组只能传给<strong>不限制数组长度</strong>的函数</p>
<p>Go数组作为函数参数值传递时，函数中的修改对调用者不影响</p>
<p>同理，<strong>传递数组的内存地址</strong>时，函数中的修改会改变数组的值</p>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><blockquote>
<p>未定义长度的数组</p>
</blockquote>
<p>切片是基于数组类型的一层封装，是对数组一个连续片段的<strong>引用</strong>(意味着多个切片表示用一个数组片段的话，那这几个切片可以共享数据！)</p>
<p>切片的数据结构 = 指向底层数组的指针 + 切片长度 + 切片容量<strong>（切片本身就是一个指针！）</strong></p>
<pre><code class="go">//切片的本质
arr := [...]int&#123;1,2,3,4&#125;
slice := []int&#123;1,2,3,4&#125;
fmt.Printf(&quot;arr的首地址为：%p\n&quot;, &amp;arr)
//切片本身就是一个指针，打印地址的时候无需&amp;地址引用
fmt.Printf(&quot;slice的首地址为：%p\n&quot;, slice)
</code></pre>
<p>nil切片(表示不存在的切片)指向底层数组的指针为nil，空切片(表示空集合)的指针则是一个地址</p>
<p><code>len(slice)</code>:返回切片<code>slice</code>的长度</p>
<p><code>cap(slice)</code>:返回切片<code>slice</code>的容量</p>
<p>0 &lt;= <code>len(slice)</code> &lt;= <code>cap(slice)</code></p>
<p><strong>切片容量的变化</strong></p>
<ul>
<li>对于底层数组容量为k的切片<code>slice[i,j]</code><ul>
<li>切片<code>slice</code>的<strong>长度len:  j - i</strong></li>
<li>切片<code>slice</code>的<strong>容量cap: k - i</strong></li>
</ul>
</li>
</ul>
<p><code>append()</code>：追加元素</p>
<ul>
<li>底层数组的智能算法：<ul>
<li>当底层数组容量(长度)小于1000时，需要扩容时总是成倍增长</li>
<li>当底层数组容量(长度)大于1000时，增长因子设为1.25，容量以1.25倍速度扩容</li>
</ul>
</li>
</ul>
<pre><code class="go">//测试append扩容
var i int
var testSlice []int
for i = 0 ;i &lt; 1100; i++&#123;
   testSlice = append(testSlice,i)
   fmt.Println(cap(testSlice))
&#125;
</code></pre>
<p>在**$GOROOT /src/runtime/slice.go** 可以查看关于append扩容的相关代码</p>
<p><img src="/2021/10/02/Go/slice.png"></p>
<p><code>copy(dst,src)</code>：复制元素src到目标dst，返回复制元素的个数</p>
<ul>
<li>dst的size需要初始化，否则无法复制</li>
</ul>
<h3 id="Range关键字"><a href="#Range关键字" class="headerlink" title="Range关键字"></a>Range关键字</h3><p>Range一般配合For进行遍历，能迭代遍历数组、切片、Map、channel等</p>
<p>遍历切片的一个样例（同理数组）：</p>
<pre><code class="go">//使用index索引和value值
    fmt.Println(&quot;---------使用index索引和value值---------&quot;)
    array := []int&#123;1,2,3,4,5&#125;
    for index,value := range array&#123;
        fmt.Printf(&quot;切片索引是：%d 的值是：%d \n&quot; ,index,value)
    &#125;

    //只使用i索引来获取数组的值
    fmt.Println(&quot;---------只使用i索引来获取数组的值---------&quot;)
    for i , _ := range array&#123;
        fmt.Printf(&quot;切片索引是：%d 的值是：%d \n&quot; ,i,array[i])
    &#125;

    //只使用v值
    fmt.Println(&quot;---------只使用v值---------&quot;)
    for _ , v := range array&#123;
        fmt.Printf(&quot;切片的值是：%d \n&quot; ,v)
    &#125;
</code></pre>
<blockquote>
<p>一些注意事项：</p>
<ul>
<li><strong>适当</strong>放弃接受index或者value，可以一定程度提升性能（for-range每次迭代都会对index和value进行赋值，数据量大时且value为String时不妨考虑只用索引来引用value值（参考样例第二段代码））</li>
<li>动态遍历中操作切片长度时，不影响循环次数，因为循环次数在开始前已经确定了</li>
<li>遍历channel时，如果channel没有数据，可能会阻塞等待</li>
</ul>
</blockquote>
<h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><p>map是无序的键值对集合，故遍历出来的结果顺序可能不同</p>
<p>map不初始化时，创建的是一个nil map，后续无法插入新的键值对</p>
<p>map和切片类似，是引用类型</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>传递指针能使多个函数明确操作同一个对象</p>
<p>传递指针相比于传递体积较大的结构体更轻量化（8bytes）</p>
<h4 id="defer延迟函数"><a href="#defer延迟函数" class="headerlink" title="defer延迟函数"></a>defer延迟函数</h4><pre><code class="go">str := &quot;string&quot;
fmt.Printf(&quot;%s \n&quot;,string(str))
for _ , v := range str&#123;
   defer fmt.Printf(&quot;%c&quot;,v)
&#125;
</code></pre>
<p>注意点:</p>
<ul>
<li>一个函数中当所有延迟操作都完成后，该函数才算完成（外围函数的语句执行完毕时，只有当延迟函数都执行完毕，该外围函数才算结束执行）</li>
</ul>
<h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>函数也属于一种数据类型，可以看做<strong>函数名</strong>是指向函数体的内存地址</p>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>一个函数(<strong>回调函数</strong>)作为另一个函数(<strong>高阶函数</strong>)的参数</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><blockquote>
<p>一个<strong>方法</strong>是一个带有接受者的函数</p>
</blockquote>
<p>未完待续。。。</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p><img src="/2021/10/02/Go/pointer.png"></p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>首字母大小写问题（相对于包的可见性）</p>
<ul>
<li>首字母大写相当于public</li>
<li>首字母小写相当于private</li>
<li>结构体内<strong>大写</strong>开头的属性能被<strong>其他包</strong>引用(public)</li>
<li>结构体内小写开头的属性只能包内引用(private)</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口只是一组共性方法的签名(只声明不实现)</p>
<p>未完待续。。。</p>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>使用 <code>defer</code>+  <code>recover()</code>来捕获\处理异常<code>panic</code></p>
<p>一个简单的demo：</p>
<pre><code class="go">func test()&#123;
   defer func() &#123;
      err := recover() //捕获异常
      if err != nil &#123;  //说明捕获到异常
         fmt.Println(&quot;捕获到异常：&quot;, err)
      &#125;
   &#125;()
   num1 := 10
   num2 := 0
   res := num1 / num2
   fmt.Printf(&quot;计算结果为: %d&quot;,res )
&#125;
func main()&#123;
   test()
   fmt.Println(&quot;程序正常运行...&quot;)
&#125;
</code></pre>
<p>控制台输出：<br><img src="/2021/10/02/Go/error1.png"></p>
<blockquote>
<p>Tips:</p>
<ul>
<li><p>Go中<code>recover</code>只在<code>defer</code>调用的函数中有效，而且<code>defer</code>要在<code>panic</code>发生前先注册</p>
</li>
<li><p>项目的开发初期多使用<code>panic</code>来强制发现错误,尽快修复</p>
</li>
<li><p>项目上线部署后使用<code>defer</code> + <code>recover</code>来避免整个Golang进程异常退出</p>
</li>
</ul>
</blockquote>
<h4 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h4><p>内置<code>error</code>是一种数据类型</p>
<p>使用struct结构体来自定义更多错误信息：</p>
<blockquote>
<p>这类结构体一般命名为<code>xxxError</code></p>
</blockquote>
<pre><code class="go">//使用结构体的方式能自定义/提供更多的错误信息
type radiusError struct &#123;
   err string
   radius float64
   area float64
&#125;
//实现error接口
func (e *radiusError) Error() string &#123;
   return fmt.Sprintf(&quot;输入半径为：%0.2f，报错信息： %s，计算出面积为：%0.2f&quot;, e.radius, e.err, e.area)
&#125;
</code></pre>
<p><code>errors.New</code> ：可以返回一个自定义的错误信息</p>
<p><code>fmt.Errorf</code>：可以返回一个自定义的错误信息(格式化)</p>
<h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><h4 id="init-函数"><a href="#init-函数" class="headerlink" title="init()函数"></a><code>init()函数</code></h4><p>一般用于初始化包所需要的特定资料，和<code>main()</code>函数作为Go中的保留函数</p>
<p>相同点：</p>
<ul>
<li>两个函数在定义的时候不能有任何的参数和返回值，只能由go程序自动调用</li>
</ul>
<p>不同点：</p>
<ul>
<li><code>init()</code> 可以在一个包中定义多个</li>
</ul>
<p><code>init()</code> 函数的执行顺序：</p>
<ul>
<li>同一个包中自上向下</li>
<li>同一个包中不同文件，将文件名按字符串进行“从小到大”排序，之后顺序调用各文件中的init()函数。</li>
<li>不同包中，相互依赖的话，最后被依赖的最先执行<code>init()</code> (被别的包调用之前先保证自己的<strong>功能完整</strong>)</li>
</ul>
<h4 id="一些注意点"><a href="#一些注意点" class="headerlink" title="一些注意点"></a>一些注意点</h4><ul>
<li>导入包的路径名，推荐使用绝对路径（从工程根目录开始）</li>
<li>导入外部的包时，可以使用在命令行使用<code>go get [外部包路径]</code>的方式取到GOPATH对应的目录中</li>
</ul>
<h3 id="并发Goroutine-amp-Channel"><a href="#并发Goroutine-amp-Channel" class="headerlink" title="并发Goroutine&amp;Channel"></a>并发Goroutine&amp;Channel</h3><p>一些基本概念：</p>
<ul>
<li><p><code>进程</code>：一个程序在一个数据集中的一次动态执行过程</p>
<ul>
<li>由 程序 + 数据集 + 进程控制块(PCB) 组成</li>
</ul>
</li>
<li><p><code>线程</code>：基本的CPU执行单元，一个进程可以包含多个线程</p>
</li>
<li><p><code>协程</code>：用户态的轻量级线程，类比理解成子程序(函数)</p>
<ul>
<li>语言中的线程和<strong>操作系统内核</strong>态线程(KSE)有所区别</li>
</ul>
</li>
</ul>
<p>量级：<strong>进程</strong> &gt; <strong>线程</strong> &gt; <strong>协程</strong></p>
<h4 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h4><p>在函数和方法调用前加上<code>go</code>,会同时运行一个新的Goroutine</p>
<p>一个小demo：</p>
<pre><code class="go">func numbers()&#123;
   for i:=0 ; i &lt;= 5 ; i++&#123;
      time.Sleep(250 * time.Millisecond)
      fmt.Printf(&quot;%d &quot;,i)
   &#125;
&#125;

func alphabets()&#123;
   for i:=&#39;a&#39; ; i &lt;= &#39;e&#39; ; i++&#123;
      time.Sleep(400 * time.Millisecond)
      fmt.Printf(&quot;%c &quot;,i)
   &#125;
&#125;
func main()&#123;
   go numbers()
   go alphabets()
   time.Sleep(5 * time.Second)
   fmt.Println(&quot;main terminated&quot;)
&#125;
</code></pre>
<p>运行结果：</p>
<p><img src="/2021/10/02/Go/Goroutine1.png"></p>
<h4 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h4><h5 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h5><ul>
<li><p><code>内核级线程模型</code>：用户线程与KSE是1对1关系**(1:1)**，调度完全由OS调度器操作![截屏2021-10-04 下午11.04.12](/Users/kokorozashiguohuang/Library/Application Support/typora-user-images/截屏2021-10-04 下午11.04.12.png)</p>
<ul>
<li>优点：实现了真正的并行，并发能力较强</li>
<li>缺点：对现场开销大，影响性能<br><img src="/2021/10/02/Go/Goroutine2.png"></li>
</ul>
</li>
<li><p>用户级线程模型：用户线程与KSE是多对1关系**(M:1)**</p>
<ul>
<li>优点：线程上下问发生在用户空间，避免了模态切换</li>
<li>缺点：只有一个处理器可以被利用<br><img src="/2021/10/02/Go/Goroutine3.png"></li>
</ul>
</li>
<li><p>两级线程模型：用户线程与KSE是多对多关系**(M:N)**</p>
</li>
</ul>
<p> <img src="/2021/10/02/Go/Goroutine4.png"></p>
<h5 id="Go并发调度：G-P-M模型"><a href="#Go并发调度：G-P-M模型" class="headerlink" title="Go并发调度：G-P-M模型"></a>Go并发调度：G-P-M模型</h5><p>（有点硬核，有机会单独写一篇博客）</p>
<h4 id="runtime包"><a href="#runtime包" class="headerlink" title="runtime包"></a>runtime包</h4><ul>
<li><p>**<code>NumCPU</code>**：返回当前系统的 <code>CPU</code> 核数量</p>
</li>
<li><p>**<code>GOMAXPROCS</code>**：设置最大的可同时使用的 <code>CPU</code> 核数(在<code>init函数</code>中操作，即在Go程序之前设置好)</p>
</li>
<li><p>**<code>NumGoroutine</code>**：返回正在执行和排队的任务总数</p>
</li>
<li><p>**<code>GOOS</code>**：返回目标操作系统</p>
</li>
<li><p><strong><code>runtime.GC</code></strong>:会让运行时系统进行一次强制性的垃圾收集</p>
</li>
<li><p><strong><code>GOROOT</code></strong> :获取goroot目录</p>
</li>
<li><p>**<code>Gosched</code>**：让当前线程让出 <code>cpu</code> 以让其它线程运行,它不会挂起当前线程，因此当前线程未来会继续执行</p>
<pre><code class="go">go func() &#123;
   for i := 0; i &lt; 5; i++ &#123;
      fmt.Println(&quot;goroutine执行中。。。&quot;)
   &#125;
   fmt.Println(&quot;goroutine执行完毕。&quot;)
&#125;()
for i := 0; i &lt; 4; i++ &#123;
   //让出时间片，先让别的协议执行，它执行完，再回来执行此协程
   runtime.Gosched()
   fmt.Println(&quot;main执行中。。。&quot;)
&#125;
fmt.Println(&quot;main执行完毕&quot;)
</code></pre>
<p>运行结果：</p>
<p><img src="/2021/10/02/Go/Goroutine5.png"></p>
</li>
<li><p>**<code>Goexit</code>**：退出当前 <code>goroutine</code>(但是<code>defer</code>语句会照常执行)</p>
<pre><code class="go">func main()&#123;

   go func()&#123;

      fmt.Println(&quot;开始一个goroutine&quot;)
      defer fmt.Println(&quot;开始defer。。。&quot;)

      //终止所在的协程
      runtime.Goexit()

      fmt.Println(&quot;goroutine结束&quot;)
   &#125;()

   //区分主协程
   time.Sleep(5 * time.Second)
   fmt.Println(&quot;主goroutine即将结束&quot;)
&#125;
</code></pre>
<p>运行结果：</p>
<blockquote>
<p>可以看到下面的goroutine打印的信息并没有出来，而<strong>defer</strong>打印的信息却出来了</p>
</blockquote>
<p><img src="/2021/10/02/Go/Goroutine6.png"></p>
</li>
</ul>
<h4 id="channel通道"><a href="#channel通道" class="headerlink" title="channel通道"></a>channel通道</h4><blockquote>
<p>“不要通过共享内存来通信，而应该通过通信来共享内存”</p>
</blockquote>
<p>用来实现goroutine之间的通道(相互通信)</p>
<p>通道定义时的类型决定了通道允许传输的数据类型</p>
<ul>
<li><strong>nil chan</strong>和<strong>nil map</strong>一样，无法使用</li>
</ul>
<blockquote>
<p>Tips:</p>
<p>可以通过ok是否为true和flase来检查通道是否关闭</p>
</blockquote>
<pre><code>v, ok := &lt;-ch
if !ok &#123;
   fmt.Println(&quot;&quot;)
   break
&#125;
</code></pre>
<h5 id="缓冲通道"><a href="#缓冲通道" class="headerlink" title="缓冲通道"></a>缓冲通道</h5><p><code>ch := make(chan type,  capacity)</code></p>
<h5 id="定向通道"><a href="#定向通道" class="headerlink" title="定向通道"></a>定向通道</h5><p><code>ch := make(chan &lt;- int)</code>:单向通道 只写</p>
<p><code>ch := make(&lt;- chan int)</code>:单向通道 只读</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>Go的反射通过空接口来进行的</p>
<p>(未完待续。。。)</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx学习记录</title>
    <url>/2021/09/02/Web_nginx/</url>
    <content><![CDATA[<h1 id="什么是Nginx？"><a href="#什么是Nginx？" class="headerlink" title="什么是Nginx？"></a>什么是Nginx？</h1><p>Nginx 是高性能的 HTTP 和反向代理的web服务器，处理高并发能力是十分强大的，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数。</p>
<span id="more"></span>

<p>写这篇博客的时候也看到了关于Web服务器的统计,Nginx已然成为使用率第一的Web服务器了</p>
<p><img src="/2021/09/02/Web_nginx/1.png"></p>
<p>其中，Nginx能做的事耳熟能详的就有反向代理、负载均衡、动静分离等</p>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>既然Nginx被称为反向代理服务器， 讲反向代理之前可以介绍一下正向代理</p>
<h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p><img src="/2021/09/02/Web_nginx/2.png"></p>
<h3 id="反向代理-1"><a href="#反向代理-1" class="headerlink" title="反向代理"></a>反向代理</h3><p><img src="/2021/09/02/Web_nginx/3.png"><br>使用反向代理有一些好处如下:</p>
<ul>
<li><p>隐藏了资源服务器的ip、端口号，一定程度上保证了主机的安全</p>
</li>
<li><p>请求量过多的时候，可以通过负载均衡分发请求给多台具有同样资源的服务器，提高了效率的同时还保证了一定的安全性</p>
</li>
</ul>
<h2 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h2><p>Nginx的反向代理、负载均衡、动静分离等功能皆是通过修改<strong>配置文件</strong>来实现的<br>这里介绍一下<strong>配置文件</strong>的相关内容<br>配置文件主要包含</p>
<ul>
<li>全局块</li>
<li>events块</li>
<li>http块<ul>
<li>http块又包含server块<ul>
<li>server块又包含server全局块和location块</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>worker_processes 4;  
... #全局块
events  #events块
&#123;
   ...
&#125;
http  #http块
&#123; 
   ...   #http全局块
   server  #server块 相当于一个虚拟机
   &#123;
      ... #server全局块
      location [Pattern]
      &#123;
         ...
      &#125;
   &#125;
   server
   &#123;
      ...
   &#125;
   ...
&#125;
</code></pre>
<h3 id="Nginx配置负载均衡"><a href="#Nginx配置负载均衡" class="headerlink" title="Nginx配置负载均衡"></a>Nginx配置负载均衡</h3><p><strong>负载均衡</strong>通过配置文件中的<code>upstream模块</code>来实现对请求的分发<br>其中，负载均衡有几种分发策略:</p>
<ul>
<li><p>轮询</p>
<pre><code>upstream lunxun &#123;
      server xx.xxx.x.xxx:8080;
      server xx.xxx.x.xxx:8081;
  &#125;

  server &#123;
      listen 80;

      location / &#123;
          proxy_pass http://lunxun;
      &#125;
  &#125;
</code></pre>
<p>所有请求轮流发送至两台服务器对应的端口中</p>
</li>
<li><p>加权轮询</p>
<pre><code>upstream quanzhong &#123;
      server xx.xxx.x.xxx:8080 weight=1; 
      server xx.xxx.x.xxx:8081 weight=2;
  &#125;

  server &#123;
      listen 80;

      location / &#123;
          proxy_pass http://quanzhong;
      &#125;
  &#125;
</code></pre>
<p>请求根据权重分发给不同服务器，举例:六个请求分发4个给weight=2的服务器,分发2个给weight=1的服务器</p>
</li>
<li><p>源地址哈希(新版本的Nginx中已经集成)</p>
<pre><code>upstream url_hash &#123;
      ip_hash;
      server xx.xxx.x.xxx:8080; 
      server xx.xxx.x.xxx:8081;
  &#125;

  server &#123;
      listen 80;

      location / &#123;
          proxy_pass http://url_hash;
      &#125;
  &#125;
</code></pre>
<p>将访问用户的ip进行哈希后的结果进行分配，每个用户定向访问到一个服务器中</p>
<blockquote>
<p>注意</p>
<blockquote>
<p>配置中Nginx服务器应处于最前端的服务器，这样才能获取用户的ip地址，否则获取的是前一个服务器的地址</p>
</blockquote>
<blockquote>
<p>ip_hash 后不能配置weight(权重)</p>
</blockquote>
<blockquote>
<p>当用户固定访问的服务器处于(down)时，客户端才会被下一个服务器接受</p>
</blockquote>
</blockquote>
</li>
<li><p>第三方调度算法(举例)</p>
<pre><code>upstream fair &#123;
      fair;
      server xx.xxx.x.xxx:8080; 
      server xx.xxx.x.xxx:8081;
  &#125;

  server &#123;
      listen 80;

      location / &#123;
          proxy_pass http://url_hash;
      &#125;
  &#125;
</code></pre>
<p>fair：用于为响应时间分配服务器组内的服务器，他是按后端服务器的响应时间来分配请求，响应时间越短的越优先分配，需要第三方模块的支持<code>nginx-upstream-fair-master</code></p>
</li>
</ul>
<blockquote>
<p>如果想了解更多关于配置文件的内容，可以查阅Nginx官方中文文档<br><a href="https://www.nginx.cn/doc/index.html">https://www.nginx.cn/doc/index.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie、Session学习记录</title>
    <url>/2021/08/30/Web_cookie_session/</url>
    <content><![CDATA[<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><ul>
<li>Cookie 翻译过来是饼干的意思。</li>
<li>Cookie 是服务器通知客户端保存键值对的一种技术。</li>
<li>客户端有了 Cookie 后，每次请求都发送给服务器。</li>
<li>每个 Cookie 的大小不能超过 4kb</li>
</ul>
<span id="more"></span>

<hr>
<h3 id="如何创建-Cookie"><a href="#如何创建-Cookie" class="headerlink" title="如何创建 Cookie"></a>如何创建 Cookie</h3><p>创建一个 Cookie 可以通过<code>respone.addcookie(cookie)</code>来创建</p>
<p>我们可以看看一个 Cookie 的创建过程如下:</p>
<p><img src="/2021/08/30/Web_cookie_session/13.jpg"></p>
<hr>
<h3 id="服务器如何获取-Cookie"><a href="#服务器如何获取-Cookie" class="headerlink" title="服务器如何获取 Cookie"></a>服务器如何获取 Cookie</h3><p>服务器获取客户端的 Cookie 只需要一行代码：<code>request.getCookies()</code></p>
<p>其中<code>request.getCookies()</code>获取的是存储在客户端的 Cookie 数组，即是<strong>全部</strong>Cookie</p>
<p>其创建过程如下:</p>
<p><img src="/2021/08/30/Web_cookie_session/14.jpg"></p>
<hr>
<h3 id="Cookie-值的修改"><a href="#Cookie-值的修改" class="headerlink" title="Cookie 值的修改"></a>Cookie 值的修改</h3><ul>
<li>方案一：</li>
</ul>
<p>1、先创建一个要修改的同名（指的就是 key）的 Cookie 对象</p>
<p>2、在构造器，同时赋于<strong>新的</strong>Cookie 值。</p>
<pre><code class="java">Cookie cookie = new Cookie(&quot;key1&quot;,&quot;newValue1&quot;);
</code></pre>
<p>3、调用<code>response.addCookie(Cookie)</code>;</p>
<ul>
<li>方案二：</li>
</ul>
<p>1、先查找到需要修改的 Cookie 对象</p>
<p>2、调用<code>setValue()</code>方法赋于新的 Cookie 值。</p>
<pre><code class="java">cookie.setValue(&quot;newValue2&quot;);
</code></pre>
<p>3、调用<code>response.addCookie()</code>通知客户端保存修改</p>
<blockquote>
<p>区别:</p>
</blockquote>
<blockquote>
<ul>
<li>方案一是创建一个新的同名 Cookie 来覆盖掉原来 Cookie</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>方案二是直接修改需要修改的 Cookie 值</li>
</ul>
</blockquote>
<hr>
<h3 id="浏览器查看-Cookie"><a href="#浏览器查看-Cookie" class="headerlink" title="浏览器查看 Cookie"></a>浏览器查看 Cookie</h3><ul>
<li>谷歌浏览器查看 Cookie</li>
</ul>
<p><img src="/2021/08/30/Web_cookie_session/15.jpg"></p>
<ul>
<li>火狐浏览器查看 Cookie</li>
</ul>
<p><img src="/2021/08/30/Web_cookie_session/16.jpg"></p>
<hr>
<h3 id="Cookie-的生命控制"><a href="#Cookie-的生命控制" class="headerlink" title="Cookie 的生命控制"></a>Cookie 的生命控制</h3><ul>
<li><p>Cookie 的生命控制指的是如何管理 Cookie 什么时候被销毁（删除）</p>
</li>
<li><p>我们可以通过<code>setMaxAge()</code>来设置 Cookie 的生命控制</p>
</li>
</ul>
<p><code>setMaxAge(正数)</code>，表示在指定的秒数后过期</p>
<p><code>setMaxAge(负数)</code>，表示浏览器一关，Cookie 就会被删除（默认值是-1）</p>
<p><code>setMaxAge(0)</code>，表示马上删除 Cookie</p>
<ul>
<li>其中，Cookie 的生命周期可以在浏览器里查看</li>
</ul>
<p><img src="/2021/08/30/Web_cookie_session/17.png"></p>
<hr>
<h3 id="Cookie-有效路径-Path-的设置"><a href="#Cookie-有效路径-Path-的设置" class="headerlink" title="Cookie 有效路径 Path 的设置"></a>Cookie 有效路径 Path 的设置</h3><ul>
<li><p>Cookie 的 path 属性可以有效的过滤哪些 Cookie 可以发送给服务器。哪些不发。</p>
</li>
<li><p>path 属性是通过请求的地址来进行有效的过滤。</p>
</li>
<li><p><code>getContextPath()</code> ===&gt;&gt;&gt;&gt; 得到工程路径</p>
</li>
</ul>
<p><img src="/2021/08/30/Web_cookie_session/18.png"></p>
<ul>
<li>代码如下:</li>
</ul>
<pre><code class="java">cookie.setPath( req.getContextPath() + &quot;/abc&quot; );
</code></pre>
<hr>
<h3 id="Cookie-验证登录的一个简单流程"><a href="#Cookie-验证登录的一个简单流程" class="headerlink" title="Cookie 验证登录的一个简单流程"></a>Cookie 验证登录的一个简单流程</h3><p><img src="/2021/08/30/Web_cookie_session/19.jpg"></p>
<blockquote>
<h2 id="Session-会话"><a href="#Session-会话" class="headerlink" title="Session 会话"></a>Session 会话</h2></blockquote>
<hr>
<h3 id="什么是-Session-会话"><a href="#什么是-Session-会话" class="headerlink" title="什么是 Session 会话?"></a>什么是 Session 会话?</h3><ul>
<li>Session 就一个接口（HttpSession）。</li>
<li>Session 就是会话。它是用来维护一个客户端和服务器之间关联的一种技术。</li>
<li>每个客户端都有自己的一个 Session 会话。</li>
<li>Session 会话中，我们经常用来保存用户登录之后的信息。</li>
</ul>
<hr>
<h3 id="如何创建-Session-和获取-id-号-是否为新"><a href="#如何创建-Session-和获取-id-号-是否为新" class="headerlink" title="如何创建 Session 和获取(id 号,是否为新)"></a>如何创建 Session 和获取(id 号,是否为新)</h3><p>如何创建和获取 Session。它们的 API 是一样的。</p>
<ul>
<li><code>request.getSession()</code></li>
</ul>
<p>第一次调用是：创建 Session 会话</p>
<p>之后调用都是：获取前面创建好的 Session 会话对象。（单例模式？）</p>
<ul>
<li><code>isNew()</code>; 判断到底是不是刚创建出来的（新的）</li>
</ul>
<p><strong>true</strong>表示刚创建</p>
<p><strong>false</strong>表示获取之前创建</p>
<ul>
<li><code>getId()</code> 得到 Session 的会话 id 值。</li>
</ul>
<p>每个会话都有一个身份证号。也就是 ID 值。而且这个 ID 是唯一的。</p>
<hr>
<h3 id="Session-域数据的存取"><a href="#Session-域数据的存取" class="headerlink" title="Session 域数据的存取"></a>Session 域数据的存取</h3><p><code>setAttribute()</code>设置当前 Session 的域数据</p>
<p><code>getAttribute()</code>获取当前 Session 的域数据</p>
<pre><code class="java">req.getSession().setAttribute(&quot;key1&quot;, &quot;value1&quot;);
req.getSession().getAttribute(&quot;key1&quot;);
</code></pre>
<h3 id="Session-生命周期控制"><a href="#Session-生命周期控制" class="headerlink" title="Session 生命周期控制"></a>Session 生命周期控制</h3><ul>
<li><code>session.setMaxInactiveInterval(int interval)</code></li>
</ul>
<p>设置 Session 的超时时间（以秒为单位），超过指定的时长，Session 就会被销毁。</p>
<p>值为<strong>正数</strong>的时候，设定 Session 的超时时长。</p>
<p><strong>负数</strong>表示永不超时（极少使用）</p>
<ul>
<li><code>getMaxInactiveInterval()</code>获取 Session 的超时时间</li>
<li><code>session.invalidate()</code> 让当前 Session 会话马上超时无效。</li>
</ul>
<p>!&gt;Session 默认的超时时间长为 30 分钟。</p>
<hr>
<h3 id="浏览器和-Session-关联的内幕"><a href="#浏览器和-Session-关联的内幕" class="headerlink" title="浏览器和 Session 关联的内幕"></a>浏览器和 Session 关联的内幕</h3><p>Session 技术，底层其实是基于 Cookie 技术来实现的。</p>
<p><img src="/2021/08/30/Web_cookie_session/20.jpg"></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Cookie、Session</tag>
      </tags>
  </entry>
  <entry>
    <title>Filter学习记录</title>
    <url>/2021/08/30/Web_filter/</url>
    <content><![CDATA[<h1 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h1><ul>
<li><p>Filter过滤器它是JavaWeb的三大组件之一。 三大组件分别是：<strong>Servlet</strong>程序、<strong>Listener</strong>监听器、<strong>Filter</strong>过滤器</p>
</li>
<li><p>Filter过滤器它是JavaEE的规范,也就是接口。</p>
</li>
<li><p>Filter过滤器它的作用是：<strong>拦截请求</strong>，<strong>过滤响应</strong>。</p>
</li>
<li><p>拦截请求常见的应用场景有：<br>权限检查,日记操作,事务管理等</p>
</li>
</ul>
<span id="more"></span>

<p>Filter的一个大致功能如下图:<br><img src="/2021/08/30/Web_filter/21.jpg"></p>
<h2 id="Filter-的体验"><a href="#Filter-的体验" class="headerlink" title="Filter 的体验"></a>Filter 的体验</h2><p>Filter过滤器的使用步骤：</p>
<ul>
<li><p>编写一个类去实现Filter接口</p>
</li>
<li><p>实现过滤方法<code>doFilter()</code></p>
</li>
<li><p>到web.xml中去配置Filter的拦截路径</p>
</li>
</ul>
<h2 id="Filter-的生命周期"><a href="#Filter-的生命周期" class="headerlink" title="Filter 的生命周期"></a>Filter 的生命周期</h2><p>Filter的生命周期包含几个方法</p>
<ul>
<li><strong>构造器方法</strong></li>
</ul>
<pre><code class="java">  public Filter() &#123;

  &#125;
</code></pre>
<ul>
<li><strong>init初始化方法</strong></li>
</ul>
<pre><code class="java">public void init(FilterConfig filterConfig) throws ServletException &#123;

    &#125;
</code></pre>
<p>第1，2步，在web 工程启动的时候执行（Filter 已经创建）</p>
<ul>
<li><strong>doFilter过滤方法</strong></li>
</ul>
<pre><code class="java">public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;

        &#125;
</code></pre>
<p>第3步，每次拦截到请求，就会执行</p>
<ul>
<li><strong>destroy销毁</strong></li>
</ul>
<pre><code class="java">  public void destroy() &#123;

  &#125;
</code></pre>
<p>第4步，停止web工程的时候，就会执行（停止web 工程，也会销毁Filter 过滤器）</p>
<h2 id="FilterConfig-类"><a href="#FilterConfig-类" class="headerlink" title="FilterConfig 类"></a>FilterConfig 类</h2><p><strong>FilterConfig</strong>类见名知义，它是Filter过滤器的<strong>配置文件类</strong>。</p>
<p>Tomcat每次创建Filter的时候，也会同时创建一个<strong>FilterConfig</strong>类，这里包含了Filter配置文件的配置信息。</p>
<p><strong>FilterConfig</strong>类的作用是获取filter过滤器的配置内容</p>
<ul>
<li><p>获取Filter的名称<code>filter-name</code>的内容</p>
</li>
<li><p>获取在Filter中配置的<code>init-param</code>初始化参数</p>
</li>
<li><p>获取<code>ServletContext</code>对象</p>
</li>
</ul>
<h3 id="FilterChain-过滤器链"><a href="#FilterChain-过滤器链" class="headerlink" title="FilterChain 过滤器链"></a>FilterChain 过滤器链</h3><blockquote>
<p>FilterChain 就是过滤器链（多个过滤器如何一起工作）</p>
</blockquote>
<p><img src="/2021/08/30/Web_filter/22.jpg"></p>
<p>当访问目标资源时，控制台得到的信息如下:</p>
<p><img src="/2021/08/30/Web_filter/23.png"></p>
<p>可以知道FilterChain有如图一的性质。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Filter</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet学习记录</title>
    <url>/2021/08/30/Web_servlet/</url>
    <content><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p> <strong>Servlet</strong> 是运行在 Web 服务器或应用服务器上的程序，</p>
<p>它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。</p>
<span id="more"></span>

<blockquote>
<h2 id="Servlet技术"><a href="#Servlet技术" class="headerlink" title="Servlet技术"></a>Servlet技术</h2></blockquote>
<hr>
<h3 id="什么是Servlet"><a href="#什么是Servlet" class="headerlink" title="什么是Servlet"></a>什么是Servlet</h3><ul>
<li><p><strong>Servlet</strong>是JavaEE规范之一，规范就是接口。</p>
</li>
<li><p><strong>Servlet</strong>就JavaWeb三大组件之一。三大组件分别是：<strong>Servlet</strong>程序、<strong>Filter</strong>过滤器、<strong>Listener</strong>监听器。</p>
</li>
<li><p><strong>Servlet</strong>是运行在服务器上的一个java小程序，它可以接收客户端发送过来的请求，并响应数据给客户端。</p>
</li>
</ul>
<hr>
<h3 id="简单实现一个Servlet程序"><a href="#简单实现一个Servlet程序" class="headerlink" title="简单实现一个Servlet程序"></a>简单实现一个Servlet程序</h3><p>(实现前需配置好Tomcat，这里不做赘述)</p>
<p>1、编写一个类去实现<strong>Servlet</strong>接口</p>
<p>实现<strong>service</strong>方法，处理请求，并响应数据</p>
<pre><code class="java">public class HelloServlet implements Servlet &#123;
/**
* service 方法是专门用来处理请求和响应的
* @param servletRequest
* @param servletResponse
* @throws ServletException
* @throws IOException
  */
  @Override
  public void service(ServletRequest servletRequest, ServletResponse servletResponse) 
          throws ServletException, IOException &#123; 
      System.out.println(&quot;Hello Servlet 被访问了&quot;);
  &#125;
&#125;
</code></pre>
<p>2、到web.xml中去配置servlet程序的访问地址</p>
<pre><code class="xml">
&lt;!-- servlet 标签给Tomcat 配置Servlet 程序--&gt;
&lt;servlet&gt;
    &lt;!--servlet-name 标签Servlet 程序起一个别名（一般是类名） --&gt;
    &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;
    &lt;!--servlet-class 是Servlet 程序的全类名--&gt;
    &lt;servlet-class&gt;com.zhiguo.servlet.HelloServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;!--servlet-mapping 标签给servlet 程序配置访问地址--&gt;
&lt;servlet-mapping&gt;
    &lt;!--servlet-name 标签的作用是告诉服务器，我当前配置的地址给哪个Servlet 程序使用--&gt;
    &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;
    &lt;!--url-pattern 标签配置访问地址&lt;br/&gt;
        / 斜杠在服务器解析的时候，表示地址为：http://ip:port/工程路径&lt;br/&gt;
        /hello 表示地址为：http://ip:port/工程路径/hello &lt;br/&gt;
        --&gt;
    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<hr>
<h3 id="url-地址到-Servlet-程序的访问"><a href="#url-地址到-Servlet-程序的访问" class="headerlink" title="url 地址到 Servlet 程序的访问"></a>url 地址到 Servlet 程序的访问</h3><p><img src="/2021/08/30/Web_servlet/2.jpg"></p>
<hr>
<h3 id="Servlet-的生命周期"><a href="#Servlet-的生命周期" class="headerlink" title="Servlet 的生命周期"></a>Servlet 的生命周期</h3><ul>
<li>执行<strong>Servlet构造器方法</strong><pre><code class="java">public HellowServlet() &#123;

&#125;
</code></pre>
其中<code>HellowServlet</code>为类名</li>
</ul>
<ul>
<li><p>执行<strong>init初始化方法</strong><br>(执行构造器和初始化方法是在第一次访问的时候创建 Servlet 程序会调用。)</p>
<pre><code class="java">  public void init(ServletConfig servletConfig) throws ServletException &#123;

  &#125;
</code></pre>
</li>
</ul>
<ul>
<li><p>执行<strong>Service方法</strong><br>(执行Servlet方法每次访问都会调用。)</p>
<pre><code class="java">public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;

      &#125;
</code></pre>
</li>
</ul>
<ul>
<li><p>执行<strong>destroy销毁方法</strong><br>(销毁方法，在web工程停止的时候调用。)</p>
<pre><code class="java">public void destroy() &#123;

      &#125;
</code></pre>
</li>
</ul>
<hr>
<h3 id="通过继承-HttpServlet-实现Servlet-程序"><a href="#通过继承-HttpServlet-实现Servlet-程序" class="headerlink" title="通过继承 HttpServlet 实现Servlet 程序"></a>通过继承 HttpServlet 实现Servlet 程序</h3><p>一般在实际项目开发中，都是使用继承<strong>HttpServlet</strong>类的方式去实现<strong>Servlet</strong>程序。</p>
<p>1、编写一个类去继承<strong>HttpServlet</strong>类</p>
<p>2、根据业务需要重写<code>doGet</code>或<code>doPost</code>方法</p>
<pre><code class="java">public class HelloServlet2 extends HttpServlet &#123;
/**
* doGet（）在get 请求的时候调用
* @param req
* @param resp
* @throws ServletException
* @throws IOException
  */
  @Override
  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException,
  IOException &#123; 
      System.out.println(&quot;HelloServlet2 的doGet 方法&quot;);
  &#125;
  /**
* doPost（）在post 请求的时候调用
* @param req
* @param resp
* @throws ServletException
* @throws IOException
  */
  @Override
  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException,
  IOException &#123; 
      System.out.println(&quot;HelloServlet2 的doPost 方法&quot;);
  &#125;
&#125;
</code></pre>
<p>3、到web.xml中配置Servlet程序的访问地址</p>
<pre><code class="xml">&lt;servlet&gt;
    &lt;servlet-name&gt;HelloServlet2&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.zhiguo.servlet.HelloServlet2&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;HelloServlet2&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello2&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<hr>
<h3 id="Servlet-类的继承体系"><a href="#Servlet-类的继承体系" class="headerlink" title="Servlet 类的继承体系"></a>Servlet 类的继承体系</h3><p><img src="/2021/08/30/Web_servlet/3.jpg"></p>
<blockquote>
<h2 id="ServletConfig-类"><a href="#ServletConfig-类" class="headerlink" title="ServletConfig 类"></a>ServletConfig 类</h2></blockquote>
<hr>
<h3 id="什么是ServletConfig-类"><a href="#什么是ServletConfig-类" class="headerlink" title="什么是ServletConfig 类"></a>什么是ServletConfig 类</h3><p><strong>Servlet</strong>程序和<strong>ServletConfig</strong>对象都是由<strong>Tomcat</strong>负责创建，我们负责使用。</p>
<p><strong>Servlet</strong>程序默认是第一次访问的时候创建，<strong>ServletConfig</strong>是每个<strong>Servlet</strong>程序创建时，<br>就创建一个对应的<strong>ServletConfig</strong>对象。</p>
<hr>
<h3 id="ServletConfig-类的三大作用"><a href="#ServletConfig-类的三大作用" class="headerlink" title="ServletConfig 类的三大作用"></a>ServletConfig 类的三大作用</h3><ul>
<li><p>可以获取Servlet 程序的别名<code>servlet-name</code>的值</p>
</li>
<li><p>获取初始化参数<code>init-param</code></p>
</li>
<li><p>获取<strong>ServletContext</strong>对象</p>
</li>
</ul>
<p>web.xml 中的配置：</p>
<pre><code class="xml">&lt;!-- servlet 标签给Tomcat 配置Servlet 程序--&gt;
&lt;servlet&gt;
    &lt;!--servlet-name 标签Servlet 程序起一个别名（一般是类名） --&gt;
    &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;
    &lt;!--servlet-class 是Servlet 程序的全类名--&gt;
    &lt;servlet-class&gt;com.zhiguo.servlet.HelloServlet&lt;/servlet-class&gt;

    &lt;!--init-param 是初始化参数--&gt;
    &lt;init-param&gt;
        &lt;!--是参数名--&gt;
        &lt;param-name&gt;username&lt;/param-name&gt;
        &lt;!--是参数值--&gt;
        &lt;param-value&gt;root&lt;/param-value&gt;
    &lt;/init-param&gt;

    &lt;!--init-param 是初始化参数--&gt;
    &lt;init-param&gt;
        &lt;!--是参数名--&gt;
        &lt;param-name&gt;url&lt;/param-name&gt;
        &lt;!--是参数值--&gt;
        &lt;param-value&gt;jdbc:mysql://localhost:3306/test&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;

&lt;!--servlet-mapping 标签给servlet 程序配置访问地址--&gt;
&lt;servlet-mapping&gt;
  &lt;!--servlet-name 标签的作用是告诉服务器，我当前配置的地址给哪个Servlet 程序使用--&gt;
  &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;
  &lt;!--
  url-pattern 标签配置访问地址&lt;br/&gt;
  / 斜杠在服务器解析的时候，表示地址为：http://ip:port/工程路径&lt;br/&gt;
  /hello 表示地址为：http://ip:port/工程路径/hello &lt;br/&gt;
  --&gt;
  &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<p><strong>Servlet</strong>程序中的代码</p>
<pre><code class="java">public void init(ServletConfig servletConfig) throws ServletException &#123;
    System.out.println(&quot;2 init 初始化方法&quot;);
// 1、可以获取Servlet 程序的别名servlet-name 的值
    System.out.println(&quot;HelloServlet 程序的别名是:&quot; + servletConfig.getServletName());
// 2、获取初始化参数init-param
    System.out.println(&quot;初始化参数username 的值是;&quot; + servletConfig.getInitParameter(&quot;username&quot;));
    System.out.println(&quot;初始化参数url 的值是;&quot; + servletConfig.getInitParameter(&quot;url&quot;));
// 3、获取ServletContext 对象
    System.out.println(servletConfig.getServletContext());
&#125;
</code></pre>
<p><strong>注意点</strong></p>
<p><img src="/2021/08/30/Web_servlet/4.jpg"></p>
<blockquote>
<h2 id="ServletContext-类"><a href="#ServletContext-类" class="headerlink" title="ServletContext 类"></a>ServletContext 类</h2></blockquote>
<hr>
<h3 id="什么是ServletContext-类"><a href="#什么是ServletContext-类" class="headerlink" title="什么是ServletContext 类"></a>什么是ServletContext 类</h3><ul>
<li><p><strong>ServletContext</strong>是一个接口，它表示<strong>Servlet</strong>上下文对象</p>
</li>
<li><p>一个<strong>web</strong>工程，只有一个<strong>ServletContext</strong>对象实例。</p>
</li>
<li><p><strong>ServletContext</strong>对象是一个域对象。</p>
</li>
<li><p><strong>ServletContext</strong>是在<strong>web</strong>工程部署启动的时候创建。<strong>在web</strong>工程停止的时候销毁。</p>
</li>
</ul>
<p>什么是<strong>域对象</strong>?</p>
<p>域对象，是可以像Map一样存取数据的对象，叫域对象。</p>
<p>这里的域指的是存取数据的操作范围，整个web 工程。</p>
<p><img src="/2021/08/30/Web_servlet/5.png"></p>
<hr>
<h3 id="ServletContext-类的四个作用"><a href="#ServletContext-类的四个作用" class="headerlink" title="ServletContext 类的四个作用"></a>ServletContext 类的四个作用</h3><ul>
<li><p>获取web.xml 中配置的上下文参数<code>context-param</code></p>
</li>
<li><p>获取当前的工程路径，格式: /工程路径</p>
</li>
<li><p>获取工程部署后在服务器硬盘上的绝对路径</p>
</li>
<li><p>像Map一样存取数据</p>
</li>
</ul>
<p>ServletContext 演示代码</p>
<pre><code class="java">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

         //获取web.xml中配置上下文的参数context——param
        ServletContext context = getServletConfig().getServletContext();

        String username = context.getInitParameter(&quot;username&quot;);
        System.out.println(&quot;username的名字是：&quot;+username);

        //获取当前工程的路径
        System.out.println(&quot;当前工程的路径是&quot;+context.getContextPath());

        //获取工程部署后在服务器硬盘上的绝对路径
        /**
         *  /斜杠被服务器解析地址为 http://ip:port/工程名/  映射到idea上的web目录&lt;/br&gt;
         */
        System.out.println(&quot;工程部署的绝对路径是&quot;+ context.getRealPath(&quot;/&quot;));
    &#125;
</code></pre>
<pre><code class="java">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        
        //获取servletcontext对象
        ServletContext context = getServletContext();
        context.setAttribute(&quot;key1&quot;,&quot;value&quot;);
        System.out.println(&quot;context数据域中key1的值是&quot;+context.getAttribute(&quot;key1&quot;));
&#125;
</code></pre>
<p>web.xml里的配置</p>
<pre><code class="xml">&lt;!--context-param 是上下文参数(它属于整个web 工程)--&gt;
&lt;context-param&gt;
    &lt;param-name&gt;username&lt;/param-name&gt;
    &lt;param-value&gt;context&lt;/param-value&gt;
&lt;/context-param&gt;
&lt;!--context-param 是上下文参数(它属于整个web 工程)--&gt;
</code></pre>
<blockquote>
<p>后续关于Web.xml的相同、类似的配置不再赘述</p>
</blockquote>
<p>服务器端结果</p>
<p><img src="/2021/08/30/Web_servlet/6.png"><br><img src="/2021/08/30/Web_servlet/7.png"></p>
<blockquote>
<h2 id="HttpServletRequest类"><a href="#HttpServletRequest类" class="headerlink" title="HttpServletRequest类"></a>HttpServletRequest类</h2></blockquote>
<hr>
<h3 id="HttpServletRequest类-的作用"><a href="#HttpServletRequest类-的作用" class="headerlink" title="HttpServletRequest类 的作用"></a>HttpServletRequest类 的作用</h3><p>每次只要有请求进入<strong>Tomcat</strong>服务器，<strong>Tomcat</strong>服务器就会把请求过来的<strong>HTTP</strong>协议信息解析好封装到Request 对象中。</p>
<p>然后传递到<strong>service</strong>方法（<code>doGet</code> 和<code>doPost</code>）中给我们使用。</p>
<p>我们可以通过<strong>HttpServletRequest</strong>对象，获取到所有请求的<br>信息。</p>
<hr>
<h3 id="HttpServletRequest类的常用方法"><a href="#HttpServletRequest类的常用方法" class="headerlink" title="HttpServletRequest类的常用方法"></a>HttpServletRequest类的常用方法</h3><p><strong>HttpServletRequest</strong>类有如下几个常用的Api:</p>
<ul>
<li><p><code>getRequestURI()</code> 获取请求的资源路径</p>
</li>
<li><p><code>getRequestURL()</code>获取请求的统一资源定位符（绝对路径）</p>
</li>
<li><p><code>getRemoteHost()</code>获取客户端的ip 地址</p>
</li>
<li><p><code>getHeader()</code>获取请求头</p>
</li>
<li><p><code>getParameter()</code>获取请求的参数</p>
</li>
<li><p><code>getParameterValues()</code>获取请求的参数（多个值的时候使用）</p>
</li>
<li><p><code>getMethod()</code>获取请求的方式GET 或POST</p>
</li>
<li><p><code>setAttribute(key, value)</code>设置域数据</p>
</li>
<li><p><code>getAttribute(key)</code>获取域数据</p>
</li>
<li><p><code>getRequestDispatcher()</code>获取请求转发对象</p>
</li>
</ul>
<hr>
<h3 id="请求的转发"><a href="#请求的转发" class="headerlink" title="请求的转发"></a>请求的转发</h3><p>什么是请求的转发?</p>
<p><strong>请求转发</strong>是指，服务器收到请求后，从一次资源跳转到另一个资源的操作。</p>
<p><img src="/2021/08/30/Web_servlet/8.png"></p>
<blockquote>
<h2 id="HttpServletResponse类"><a href="#HttpServletResponse类" class="headerlink" title="HttpServletResponse类"></a>HttpServletResponse类</h2></blockquote>
<hr>
<h3 id="HttpServletResponse类的作用"><a href="#HttpServletResponse类的作用" class="headerlink" title="HttpServletResponse类的作用"></a>HttpServletResponse类的作用</h3><p><strong>HttpServletResponse</strong>类和<strong>HttpServletRequest</strong>类一样。</p>
<p>每次请求进来，<strong>Tomcat</strong>服务器都会创建一个<strong>Response</strong>对象传递给<strong>Servlet</strong>程序去使用。</p>
<p><strong>HttpServletRequest</strong>表示请求过来的信息，<strong>HttpServletResponse</strong>表示所有响应的信息，<br>我们如果需要设置返回给客户端的信息，都可以通过<strong>HttpServletResponse</strong>对象来进行设置。</p>
<h3 id="两个输出流的说明"><a href="#两个输出流的说明" class="headerlink" title="两个输出流的说明"></a>两个输出流的说明</h3><ul>
<li><p>字节流<br><code>getOutputStream()</code>常用于下载（传递二进制数据）</p>
</li>
<li><p>字符流<br><code>getWriter()</code> 常用于回传字符串（常用）</p>
</li>
</ul>
<p><strong>两个流同时只能使用一个。</strong></p>
<h3 id="如何往客户端传送数据"><a href="#如何往客户端传送数据" class="headerlink" title="如何往客户端传送数据"></a>如何往客户端传送数据</h3><pre><code class="java">public class ResponseIOServlet extends HttpServlet &#123;

  @Override
  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
      
    //往客户端回传字符流
    PrintWriter writer = resp.getWriter();
    writer.println(&quot;response&#39;s content!&quot;);
    writer.println(&quot;国哥真的帅呀！&quot;);
  &#125;
&#125;
</code></pre>
<p><img src="/2021/08/30/Web_servlet/11.png"></p>
<h3 id="响应的乱码解决"><a href="#响应的乱码解决" class="headerlink" title="响应的乱码解决"></a>响应的乱码解决</h3><p>我们在上面往客户端传送数据时会发现中文编码格式会存在问题</p>
<p>“<strong>国哥真的帅呀！</strong>“显示成了”<strong>？？？？？？</strong>“</p>
<p>这是因为服务器默认的编码格式为<strong>ISO-8859-1</strong></p>
<p>我们可以分别通过<code>setCharacterEncoding()</code>、<code>setHeader()</code>和<code>setContentType()</code>两种方法来设置服务器和浏览器的编码格式</p>
<pre><code class="java">public class ResponseIOServlet extends HttpServlet &#123;

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;

        //System.out.println(resp.getCharacterEncoding()); //默认ISO-8859-1

        //设置服务器字符集为UTF-8
        // resp.setCharacterEncoding(&quot;UTF-8&quot;);

        //通过响应头，设置浏览器也使用UTF-8字符集
        // resp.setHeader(&quot;Content-Type&quot;,&quot;text/html;charset=UTF-8&quot;);

        //同时设置服务器和客户端为UTF-8字符集，还设置了响应头
        //在获取流对象前调用才有效
        resp.setContentType(&quot;text/html;charset=UTF-8&quot;);


        //往客户端回传字符流
        PrintWriter writer = resp.getWriter();
        writer.println(&quot;response&#39;s content!&quot;);
        writer.println(&quot;国哥真的帅呀！&quot;);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>推荐使用<code>setContentType()</code>一步到位</p>
</blockquote>
<p>此时访问浏览器会发现</p>
<p><img src="/2021/08/30/Web_servlet/12.png"></p>
<p>**”国哥真的帅呀！”**显示出来了!</p>
<h3 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h3><p><strong>请求重定向</strong>，是指客户端给服务器发请求，然后服务器告诉客户端说。我给你一些地址。你去新地址访问。<br>叫请求重定向（因为之前的地址可能已经被废弃）</p>
<p><img src="/2021/08/30/Web_servlet/9.png"></p>
<p>实现代码如下:</p>
<p><img src="/2021/08/30/Web_servlet/10.png"></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC学习记录</title>
    <url>/2021/08/30/Mysql_JDBC/</url>
    <content><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><blockquote>
<p>这里记录我学习JDBC连接数据库操作时的笔记和知识总结，方便后续的复习</p>
</blockquote>
<span id="more"></span>

<h2 id="为什么需要JDBC"><a href="#为什么需要JDBC" class="headerlink" title="为什么需要JDBC"></a>为什么需要JDBC</h2><p><img src="/2021/08/30/Mysql_JDBC/JDBC_1.png"></p>
<p>没有JDBC之前，程序员们操作不同数据库时，都是我们通过代码去实现的。</p>
<p>而连接MySQL的代码，和连接Oracle的代码是不同的；</p>
<p>这就导致了，我们<strong>更换数据库时就要去修改代码</strong>，代码的<strong>可复用性</strong>和<strong>移植性</strong>就显得很低了。</p>
<h2 id="什么是JDBC"><a href="#什么是JDBC" class="headerlink" title="什么是JDBC"></a>什么是JDBC</h2><ul>
<li><p>JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的<strong>公共接口</strong>（一组API），<br>定义了用来访问数据库的标准Java类库，（<strong>java.sql,javax.sql</strong>）使用这些类库可以以一种<strong>标准</strong>的方法、方便地访问数据库资源。</p>
</li>
<li><p>JDBC为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</p>
</li>
<li><p>JDBC的目标是使Java程序员使用JDBC可以连接任何<strong>提供了JDBC驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</p>
</li>
</ul>
<blockquote>
<p>说人话就是提供了一个<strong>通用的接口</strong>(<strong>标准</strong>)来<strong>操作数据库</strong>，在程序中加载的类都是<strong>Java原生提供的类</strong>，<br>并不包含外部引用的类，提高了代码的<strong>可复用性</strong>和<strong>移植性</strong>。</p>
</blockquote>
<p><img src="/2021/08/30/Mysql_JDBC/JDBC_2.png"></p>
<ul>
<li>JDBC接口（API）包括两个层次：<ul>
<li><strong>面向应用的API</strong>：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。</li>
<li> <strong>面向数据库的API</strong>：Java Driver API，供开发商开发数据库驱动程序用。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>JDBC是Sun公司(那时还没被Oracle收购)提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。</strong></p>
<p><strong>不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。                                                                ————面向接口编程</strong></p>
</blockquote>
<h2 id="JDBC的功能实现"><a href="#JDBC的功能实现" class="headerlink" title="JDBC的功能实现"></a>JDBC的功能实现</h2><p><img src="/2021/08/30/Mysql_JDBC/JDBC_3.png"><br>步骤简单理解为就是:</p>
<ul>
<li><p>连接数据库</p>
</li>
<li><p>执行sql语句</p>
</li>
<li><p>如果是<strong>查询</strong>则通过Result对象来接受<strong>结果数据</strong>(其中得提前创建接收<strong>对应</strong>数据的Java对象)</p>
</li>
<li><p>断开数据库连接</p>
</li>
</ul>
<p>其中，</p>
<ul>
<li><p>数据库的连接等由程序员使用<strong>数据库连接池</strong>完成</p>
</li>
<li><p>执行sql语句由程序员使用<strong>JDBC工具类库实现CUDR操作</strong>完成</p>
</li>
</ul>
<p>当然，数据库的连接和断开以及CUDR操作可以自己写，但是这也存在一些弊端，下面会介绍道。</p>
<h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><h3 id="JDBC数据库连接池的必要性"><a href="#JDBC数据库连接池的必要性" class="headerlink" title="JDBC数据库连接池的必要性"></a>JDBC数据库连接池的必要性</h3><ul>
<li><p>在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：</p>
<ul>
<li><strong>在主程序（如servlet、beans）中建立数据库连接</strong></li>
<li><strong>进行sql操作</strong></li>
<li><strong>断开数据库连接</strong></li>
</ul>
</li>
<li><p>这种模式开发，存在的问题:</p>
<ul>
<li>普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。<strong>数据库的连接资源并没有得到很好的重复利用。</strong>若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</li>
<li><strong>对于每一次数据库连接，使用完后都得断开。</strong>否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？）</li>
<li><strong>这种开发不能控制被创建的连接对象数</strong>，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。</li>
</ul>
</li>
</ul>
<h3 id="数据库连接池技术"><a href="#数据库连接池技术" class="headerlink" title="数据库连接池技术"></a>数据库连接池技术</h3><ul>
<li><p>为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。</p>
</li>
<li><p><strong>数据库连接池的基本思想</strong>：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。</p>
</li>
<li><p><strong>数据库连接池</strong>负责分配、管理和释放数据库连接，它<strong>允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</strong>。</p>
</li>
<li><p>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由<strong>最小数据库连接数来设定</strong>的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的<strong>最大数据库连接数量</strong>限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。<br><img src="/2021/08/30/Mysql_JDBC/JDBC_4.png"></p>
</li>
<li><p><strong>工作原理：</strong><br><img src="/2021/08/30/Mysql_JDBC/JDBC_5.png"></p>
</li>
<li><p><strong>数据库连接池技术的优点</strong></p>
<p><strong>1. 资源重用</strong></p>
<p>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</p>
<p><strong>2. 更快的系统反应速度</strong></p>
<p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</p>
<p><strong>3. 新的资源分配手段</strong></p>
<p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</p>
<p><strong>4. 统一的连接管理，避免数据库连接泄漏</strong></p>
<p>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</p>
</li>
</ul>
<h3 id="多种开源的数据库连接池"><a href="#多种开源的数据库连接池" class="headerlink" title="多种开源的数据库连接池"></a>多种开源的数据库连接池</h3><ul>
<li><p>JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：</p>
<ul>
<li><strong>DBCP</strong> 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。<strong>速度相对c3p0较快</strong>，但因自身存在BUG，Hibernate3已不再提供支持。</li>
<li><strong>C3P0</strong> 是一个开源组织提供的一个数据库连接池，<strong>速度相对较慢，稳定性还可以。</strong>hibernate官方推荐使用</li>
<li><strong>Proxool</strong> 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，<strong>稳定性较c3p0差一点</strong></li>
<li><strong>BoneCP</strong> 是一个开源组织提供的数据库连接池，速度快</li>
<li><strong>Druid</strong> 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快</li>
</ul>
</li>
<li><p>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池</p>
</li>
<li><p><strong>DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。</strong></p>
</li>
<li><p>特别注意：</p>
<ul>
<li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此<strong>整个应用只需要一个数据源即可。</strong></li>
<li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>现在主要是使用德鲁伊连接池。</li>
</ul>
</blockquote>
<blockquote>
<p>一个简单的连接实例:</p>
</blockquote>
<pre><code class="java">public class DruidTest &#123;

    @Test
    public void getConnection() throws Exception&#123;

        Properties pros = new Properties();

        InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;druid.properties&quot;);

        //装载配置文件数据
        pros.load(is);
        
        DataSource source = DruidDataSourceFactory.createDataSource(pros);

        Connection conn = source.getConnection();

        System.out.println(conn);
    &#125;
&#125;
</code></pre>
<p>其中，src下的配置文件为：【druid.properties】</p>
<pre><code class="java">url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true
username=root
password=123456
driverClassName=com.mysql.jdbc.Driver

</code></pre>
<ul>
<li>详细配置参数(在配置文件内添加)：</li>
</ul>
<table>
<thead>
<tr>
<th><strong>配置</strong></th>
<th><strong>缺省</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td></td>
<td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。   如果没有配置，将会生成一个名字，格式是：”DataSource-” +   System.identityHashCode(this)</td>
</tr>
<tr>
<td>url</td>
<td></td>
<td>连接数据库的url，不同数据库不一样。例如：mysql :   jdbc:mysql://10.20.153.104:3306/druid2      oracle :   jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td>
</tr>
<tr>
<td>username</td>
<td></td>
<td>连接数据库的用户名</td>
</tr>
<tr>
<td>password</td>
<td></td>
<td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter">https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter</a></td>
</tr>
<tr>
<td>driverClassName</td>
<td></td>
<td>根据url自动识别   这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)</td>
</tr>
<tr>
<td>initialSize</td>
<td>0</td>
<td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td>
</tr>
<tr>
<td>maxActive</td>
<td>8</td>
<td>最大连接池数量</td>
</tr>
<tr>
<td>maxIdle</td>
<td>8</td>
<td>已经不再使用，配置了也没效果</td>
</tr>
<tr>
<td>minIdle</td>
<td></td>
<td>最小连接池数量</td>
</tr>
<tr>
<td>maxWait</td>
<td></td>
<td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>false</td>
<td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td>
</tr>
<tr>
<td>maxOpenPreparedStatements</td>
<td>-1</td>
<td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td>
</tr>
<tr>
<td>validationQuery</td>
<td></td>
<td>用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。</td>
</tr>
<tr>
<td>testOnBorrow</td>
<td>true</td>
<td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td>
</tr>
<tr>
<td>testOnReturn</td>
<td>false</td>
<td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</td>
</tr>
<tr>
<td>testWhileIdle</td>
<td>false</td>
<td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td>
</tr>
<tr>
<td>timeBetweenEvictionRunsMillis</td>
<td></td>
<td>有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td>
</tr>
<tr>
<td>numTestsPerEvictionRun</td>
<td></td>
<td>不再使用，一个DruidDataSource只支持一个EvictionRun</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td></td>
<td></td>
</tr>
<tr>
<td>connectionInitSqls</td>
<td></td>
<td>物理连接初始化的时候执行的sql</td>
</tr>
<tr>
<td>exceptionSorter</td>
<td></td>
<td>根据dbType自动识别   当数据库抛出一些不可恢复的异常时，抛弃连接</td>
</tr>
<tr>
<td>filters</td>
<td></td>
<td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：   监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</td>
</tr>
<tr>
<td>proxyFilters</td>
<td></td>
<td>类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td>
</tr>
</tbody></table>
<h2 id="JDBC工具类库实现CUDR操作"><a href="#JDBC工具类库实现CUDR操作" class="headerlink" title="JDBC工具类库实现CUDR操作"></a>JDBC工具类库实现CUDR操作</h2><ul>
<li>commons-dbutils 是 Apache 组织提供的一个<strong>开源JDBC工具类库</strong>，它是对JDBC的简单封装，学习成本极低，<br>并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。</li>
</ul>
<h3 id="DbUtils类"><a href="#DbUtils类" class="headerlink" title="DbUtils类"></a>DbUtils类</h3><ul>
<li><p>DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：</p>
<ul>
<li><p><strong>public static void close(…) throws java.sql.SQLException</strong>：</p>
<p>DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。</p>
</li>
<li><p><strong>public static void closeQuietly(…)</strong>:</p>
<p>这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。</p>
</li>
<li><p><strong>public static void commitAndClose(Connection conn)throws SQLException</strong>：</p>
<p>用来提交连接的事务，然后关闭连接</p>
</li>
<li><p>**public static void commitAndCloseQuietly(Connection conn)**：</p>
<p>用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。</p>
</li>
<li><p><strong>public static void rollback(Connection conn)throws SQLException</strong>：</p>
<p>允许conn为null，因为方法内部做了判断</p>
</li>
<li><p><strong>public static void rollbackAndClose(Connection conn)throws SQLException</strong>:</p>
<p>事务的回滚</p>
</li>
<li><p><strong>rollbackAndCloseQuietly(Connection)</strong>:</p>
<p>安静的事务回滚？</p>
</li>
<li><p>**public static boolean loadDriver(java.lang.String driverClassName)**：</p>
<p>这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。</p>
</li>
</ul>
</li>
</ul>
<h3 id="QueryRunner类"><a href="#QueryRunner类" class="headerlink" title="QueryRunner类"></a>QueryRunner类</h3><ul>
<li><p><strong>该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。</strong></p>
</li>
<li><p>QueryRunner类提供了两个构造器：</p>
<ul>
<li>默认的构造器</li>
<li>需要一个 javax.sql.DataSource 来作参数的构造器</li>
</ul>
</li>
<li><p>QueryRunner类的主要方法：</p>
<ul>
<li><p><strong>更新</strong></p>
<ul>
<li><p>public int update(Connection conn, String sql, Object… params) throws SQLException:</p>
<p>用来执行一个更新（插入、更新或删除）操作。</p>
</li>
<li><p> ……</p>
</li>
</ul>
</li>
<li><p><strong>插入</strong></p>
<ul>
<li>public <T> T insert(Connection conn,String sql,ResultSetHandler<T> rsh, Object… params) throws SQLException：</T></T></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>  只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值
- ....
</code></pre>
<ul>
<li><p><strong>批处理</strong></p>
<ul>
<li><p>public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException：</p>
<p>支持INSERT, UPDATE, or DELETE语句</p>
</li>
<li><p>public <T> T insertBatch(Connection conn,String sql,ResultSetHandler<T> rsh,Object[][] params)throws SQLException：</T></T></p>
<p>只支持INSERT语句</p>
</li>
<li><p>…..</p>
</li>
</ul>
</li>
<li><p><strong>查询</strong></p>
<ul>
<li><p>public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：</p>
<p>执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。</p>
</li>
<li><p>……</p>
</li>
</ul>
</li>
<li><p>一些简单的测试</p>
<pre><code class="java">//测试插入
@Test
public void testInsert() throws SQLException&#123;
Connection conn = null;

      try &#123;
          QueryRunner Runner = new QueryRunner();

          conn = JDBCutils.getConnection();

          String sql = &quot;insert into customers(name,email,birth)value(?,?,?)&quot;;

          Runner.update(conn,sql,&quot;杰哥&quot;,&quot;jiege@qq.com&quot;,&quot;2000-11-11&quot;);

      &#125; catch (Exception e) &#123;
          e.printStackTrace();
      &#125;
  &#125;
</code></pre>
</li>
</ul>
<h3 id="ResultSetHandler接口及实现类"><a href="#ResultSetHandler接口及实现类" class="headerlink" title="ResultSetHandler接口及实现类"></a>ResultSetHandler接口及实现类</h3><ul>
<li><p>该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。</p>
</li>
<li><p>ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。</p>
</li>
<li><p>接口的主要实现类：</p>
<ul>
<li><p>ArrayHandler：把结果集中的第一行数据转成对象数组。</p>
</li>
<li><p>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。</p>
</li>
<li><p><strong>BeanHandler：</strong>将结果集中的第一行数据封装到一个对应的JavaBean实例中。</p>
</li>
<li><p><strong>BeanListHandler：</strong>将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</p>
</li>
<li><p>ColumnListHandler：将结果集中某一列的数据存放到List中。</p>
</li>
<li><p>KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</p>
</li>
<li><p><strong>MapHandler：</strong>将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</p>
</li>
<li><p><strong>MapListHandler：</strong>将结果集中的每一行数据都封装到一个Map里，然后再存放到List</p>
</li>
<li><p><strong>ScalarHandler：</strong>查询单个值对象</p>
</li>
</ul>
</li>
<li><p>一些简单的测试</p>
<pre><code class="java">//测试查询多条记录
@Test
public void testQueryList() throws SQLException &#123;
Connection conn = null;
try &#123;
QueryRunner Runner = new QueryRunner();

          conn = JDBCutils.getConnection();

          String sql = &quot;select id ,name,email,birth from Customers where id &lt; ?&quot;;

          BeanListHandler&lt;Customer&gt; handler = new BeanListHandler&lt;Customer&gt;(Customer.class);

          List&lt;Customer&gt; list = Runner.query(conn, sql, handler, 23);

          list.forEach(System.out::println);

      &#125; catch (Exception e) &#123;
          e.printStackTrace();
      &#125;
  &#125;
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker File的常用指令</title>
    <url>/2021/08/29/Docker_file/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>Docker File</code>被用来构建一个自定义的image镜像，就像把镜像的构建中每一步添加的配置、文件等都写入一个配置文件中，在构建自定义镜像时能根据这个配置文件来配置相应的信息。</p>
<span id="more"></span>

<h2 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h2><h3 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a><code>FROM</code> 指定基础镜像</h3><h3 id="RUN-用来执行命令行命令"><a href="#RUN-用来执行命令行命令" class="headerlink" title="RUN  用来执行命令行命令"></a><code>RUN</code>  用来执行命令行命令</h3><h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a><code>COPY</code> 复制文件</h3><p>格式:</p>
<ul>
<li><p><code>COPY &lt;源路径&gt;...&lt;目标路径&gt;</code></p>
</li>
<li><p><code>COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></p>
</li>
</ul>
<p><code>COPY</code>指令会从构建的上下文目录中的<code>&lt;源路径&gt;</code>，复制内容到<code>&lt;目标路径&gt;</code></p>
<blockquote>
<p>注意⚠️: <code>COPY</code>会保留源文件的元数据，包括读写权限等</p>
</blockquote>
<h3 id="ADD-比COPY高级的复制文件"><a href="#ADD-比COPY高级的复制文件" class="headerlink" title="ADD 比COPY高级的复制文件"></a><code>ADD</code> 比COPY高级的复制文件</h3><p>相对于<code>COPY</code>的文件复制功能，<code>ADD</code>中：</p>
<ul>
<li><code>&lt;源路径&gt;</code>可以是一个<code>URL</code>，Docker引擎会尝试从链接下载数据文件，并自动设置文件的权限600，<br>如果需要修改文件的权限，则还需要添加一层RUN来修改； </li>
<li>如果<code>&lt;源路径&gt;</code>是一份压缩文件，则<code>ADD</code>会尝试解压这份压缩文件并添加到<code>&lt;目标路径&gt;</code>中</li>
</ul>
<blockquote>
<p>不需要自动解压缩的情景下更推荐使用<code>COPY</code></p>
</blockquote>
<h3 id="CMD-在容器中启动命令"><a href="#CMD-在容器中启动命令" class="headerlink" title="CMD 在容器中启动命令"></a><code>CMD</code> 在容器中启动命令</h3><p>Docker在主机上的体现不是一个虚拟机，而是一个进程，而<code>CMD</code>指令就是用于指定<strong>默认</strong>(后面要考 doge.jpg)容器主进程的启动命令</p>
<p>在镜像运行时可以指定新的命令来替代镜像设置中的这个默认命令</p>
<p><code>CMD</code>的格式有如下几种：</p>
<ul>
<li><code>shell</code> 格式：CMD &lt;命令&gt;</li>
<li><code>exec</code> 格式：CMD [“可执行文件”, “参数1”, “参数2”…]</li>
<li><code>参数列表</code> 格式：CMD [“参数1”, “参数2”…]。在指定了<code>ENTRYPOINT</code>指令后，用<code>CMD</code>指定具体的参数。</li>
</ul>
<blockquote>
<p>指令格式上更推荐使用<code>exec</code> 格式，其中的命令会被解析为JSON数组，注意一定要用双引号” 而不是单引号’</p>
</blockquote>
<h3 id="ENTRYPOINT-命令入口点"><a href="#ENTRYPOINT-命令入口点" class="headerlink" title="ENTRYPOINT 命令入口点"></a><code>ENTRYPOINT</code> 命令入口点</h3><p><code>ENTRYPOINT</code>顾名思义，命令入口点</p>
<p>格式：<br><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] </code></p>
<p><code>ENTRYPOINT command param1 param2</code></p>
<p>第一种格式下能接受到来自<code>CMD</code>和<code>Docker run</code>后添加的参数，优先接受<code>Docker run</code>的参数</p>
<p>第二种格式下无法接受来自<code>CMD</code>和<code>Docker run</code>添加的参数</p>
<p>更推荐使用第一种格式</p>
<h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a><code>ENV</code> 设置环境变量</h3><p><code>ENV</code>用来设置环境变量，能供后续的指令使用</p>
<p><code>ENV</code>格式有两种：</p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<h3 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a><code>ARG</code> 构建参数</h3><p><code>ARG</code>用来构建参数名称和定义默认值，其和<code>ENV</code>环境变量不同的是在容器运行时，是不存在这些<code>ARG</code>构建的参数的，但可以在<code>Dockerhistory</code>中查看</p>
<p>格式：<br><code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p>
<p>关于<code>ARG</code>的使用细节，可以参考如下：</p>
<pre><code>ARG DOCKER_USERNAME=library

FROM $&#123;DOCKER_USERNAME&#125;/alpine

# 在FROM 之后使用变量，必须在每个阶段分别指定
ARG DOCKER_USERNAME=library

RUN set -x ; echo $&#123;DOCKER_USERNAME&#125;

FROM $&#123;DOCKER_USERNAME&#125;/alpine

# 在FROM 之后使用变量，必须在每个阶段分别指定
ARG DOCKER_USERNAME=library

RUN set -x ; echo $&#123;DOCKER_USERNAME&#125;
</code></pre>
<h3 id="VOLUME-构建匿名挂载卷"><a href="#VOLUME-构建匿名挂载卷" class="headerlink" title="VOLUME 构建匿名挂载卷"></a><code>VOLUME</code> 构建匿名挂载卷</h3><p>适用场景，在例如数据库等动态数据读写较多和需要保存的情况下，应该将数据保存在容器的外部</p>
<p>在Docker File中添加VOLUME是以防用户在<code>Docker run</code>中不指定挂载，应用正常运行的时候不会在容器中写入大量的数据</p>
<p>Docker挂载卷默认保存地址是在 <code>var/lib/docker/volumes</code> 下</p>
<p>格式：</p>
<ul>
<li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li>
<li><code>VOLUME &lt;路径&gt;</code></li>
</ul>
<h3 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a><code>EXPOSE</code> 声明端口</h3><p>这里的声明端口只是推荐使用端口，实际上并不会在<code>Docker run</code>时开启这个端口，在用户使用<code>-P</code>随机指定端口时候，会自动随机选择一个宿主机端口映射到<code>EXPOSE</code>声明的端口</p>
<p>一个例子:</p>
<p>这是tomcat镜像中的dockerfile声明的一个端口<br><img src="/2021/08/29/Docker_file/1.png"><br>在docker中添加<code>-P</code>启动三个tomcat容器<br><img src="/2021/08/29/Docker_file/2.png"><br>可以看到宿主机的端口都不约而同的映射到了Expose中的8080端口</p>
<h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a><code>WORKDIR</code> 指定工作目录</h3><p><code>WORKDIR</code>指令能使后续各层的当前目录都会被改为指定工作目录</p>
<p>格式：<br><code>WORKDIR &lt;工作目录路径&gt;</code></p>
<h3 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a><code>USER</code> 指定当前用户</h3><p>切换到事先建立好的指定用户，和<code>WORKDIR</code>指令一样能对后续各层产生影响</p>
<p>格式：<br><code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p>
<h3 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a><code>HEALTHCHECK</code> 健康检查</h3><p>能判断容器的状态是否正常</p>
<p>格式：</p>
<ul>
<li><p><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</p>
<ul>
<li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</li>
<li><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li>
<li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 unhealthy，默认 3 次。</li>
</ul>
</li>
<li><p><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</p>
</li>
</ul>
<p>这是不添加<code>HEALTHCHECK</code>指令时候，只能通过判断<strong>容器主进程是否退出</strong>来判断<strong>容器状态是否异常</strong><br><img src="/2021/08/29/Docker_file/3.png"><br>当容器因为死锁或者死循环而进程不退出时，依然无法辨别容器是否异常</p>
<p>使用<code>HEALTHCHECK</code>后</p>
<ul>
<li>容器启动时，最初的状态为 <code>(health: starting)</code></li>
<li>过几秒后，健康状态变化为了 <code>(healthy)</code></li>
<li>健康检查连续失败超过了重试次数，状态就会变为<code>(unhealthy)</code></li>
</ul>
<h3 id="ONBUILD-辅助构建镜像"><a href="#ONBUILD-辅助构建镜像" class="headerlink" title="ONBUILD 辅助构建镜像"></a><code>ONBUILD</code> 辅助构建镜像</h3><p>格式：<br><code>ONBUILD &lt;其它指令&gt;</code> </p>
<p>当以此镜像为基础镜像，去构建下一级镜像时(FROM xxx)，<code>ONBUILD</code>后面的指令才会被执行</p>
]]></content>
      <categories>
        <category>运维部署</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈Docker的卷挂载</title>
    <url>/2021/08/11/Docker_volume_mount/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Docker卷挂载提供了以下便利：</p>
<ul>
<li>能在宿主机上很方便地访问容器中的文件</li>
<li>能在多个容器之间共享数据</li>
<li>容器数据的可持久化</li>
</ul>
<span id="more"></span>

<h3 id="数据的覆盖问题"><a href="#数据的覆盖问题" class="headerlink" title="数据的覆盖问题"></a>数据的覆盖问题</h3><ul>
<li><p>如果挂载一个空的数据卷到容器中的一个非空目录中，那么这个目录下的文件会被复制到数据卷中。</p>
</li>
<li><p>如果挂载一个非空的数据卷到容器中的一个目录中，那么容器中的目录中会显示数据卷中的数据。如果原来容器中的目录中有数据，那么这些原始数据会被隐藏掉。</p>
</li>
</ul>
<p> 总结： 宿主机数据卷空时，优先容器数据；宿主机数据卷非空时，优先宿主机数据</p>
<h3 id="数据卷的位置问题"><a href="#数据卷的位置问题" class="headerlink" title="数据卷的位置问题"></a>数据卷的位置问题</h3><ul>
<li>所有的docker容器内的卷，没有指定目录的情况下都是在/var/lib/docker/volumes/xxxx/_data下 通过具名挂载可以方便地找到一个卷，大多数情况在使用具名挂载</li>
</ul>
<h3 id="数据卷的备份、恢复、迁移问题"><a href="#数据卷的备份、恢复、迁移问题" class="headerlink" title="数据卷的备份、恢复、迁移问题"></a>数据卷的备份、恢复、迁移问题</h3><p>(这里留个坑。。。)</p>
<h3 id="一些常用的操作"><a href="#一些常用的操作" class="headerlink" title="一些常用的操作"></a>一些常用的操作</h3><p>指定路径挂载</p>
<p><code>-v &lt;宿主机地址&gt;:&lt;容器地址&gt;</code> : 将宿主机的文件\目录挂载至容器内</p>
<p>匿名挂载</p>
<p><code>-v &lt;容器地址&gt;</code> : 默认分配你给挂载卷一个名字</p>
<p>具名挂载</p>
<p><code>-v &lt;卷名&gt;:&lt;容器地址&gt;</code> : 自定义挂载卷名字</p>
<p>读写权限(添加在&lt;容器地址&gt;后)</p>
<p><code>:ro/:readonly</code> : 只读<br><code>:rw/:readwrite</code> : 可读可写</p>
<p>查看挂载情况</p>
<p><code>docker volume ls</code><br><code>docker volume inspect &lt;卷名&gt;</code></p>
]]></content>
      <categories>
        <category>运维部署</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
</search>
